<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HOTH DEFENSE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: none;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 80;
            pointer-events: auto;
            cursor: pointer;
            background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.95));
        }

        .overlay-text {
            color: #88ccff;
            text-align: center;
            text-shadow: 0 0 15px rgba(100, 180, 255, 0.5);
        }

        .overlay-text .big {
            font-size: 16px;
            display: block;
            margin-bottom: 16px;
            letter-spacing: 3px;
        }

        .overlay-text .med {
            font-size: 9px;
            display: block;
            margin-bottom: 10px;
            color: #ff8844;
        }

        .overlay-text .small {
            font-size: 8px;
            display: block;
            opacity: 0.8;
            color: #ff8844;
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            49% {
                opacity: 0.8
            }

            50%,
            100% {
                opacity: 0.2
            }
        }

        @media (min-width:600px) {
            .overlay-text .big {
                font-size: 26px;
            }
        }
        #exitBtn{position:fixed;top:10px;right:10px;z-index:100;font-family:'Press Start 2P',monospace;font-size:9px;color:#999;text-decoration:none;background:rgba(0,0,0,0.7);padding:6px 12px;border:1px solid #555;border-radius:2px;cursor:pointer;transition:all 0.15s}
        #exitBtn:hover{border-color:#88ccff;color:#88ccff;background:rgba(0,20,40,0.8)}
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <div class="overlay" id="startOverlay">
        <div class="overlay-text">
            <span class="big">&#10052; HOTH DEFENSE &#10052;</span>
            <span class="med">THE EMPIRE HAS FOUND THE BASE</span>
            <span class="med" style="color:#ff8844">MAN YOUR SNOWSPEEDER &mdash; DEFEND ECHO BASE</span>
            <span class="small">&#9658; CLICK OR PRESS ENTER &#9668;</span>
            <br><a href="Index.html" style="font-family:'Press Start 2P',monospace;font-size:8px;color:#ff0;text-decoration:none;background:rgba(0,0,0,0.6);padding:6px 10px;border:1px solid #ff0;border-radius:3px">&#9664; ARCADE</a>
        </div>
    </div>

    <div class="overlay" id="gameOverOverlay" style="display:none;">
        <div class="overlay-text">
            <span class="big" style="color:#88ccff">BASE DESTROYED</span>
            <span class="med" id="finalScore"></span>
            <span class="small">&#9658; CLICK OR PRESS ENTER &#9668;</span>
            <br><a href="Index.html" style="font-family:'Press Start 2P',monospace;font-size:8px;color:#ff0;text-decoration:none;background:rgba(0,0,0,0.6);padding:6px 10px;border:1px solid #ff0;border-radius:3px">&#9664; ARCADE</a>
        </div>
    </div>

    <div class="overlay" id="winOverlay" style="display:none;background:transparent;"><div style="position:absolute;bottom:15%;left:50%;transform:translateX(-50%)"><a href="Index.html" style="font-family:'Press Start 2P',monospace;font-size:8px;color:#ff0;text-decoration:none;background:rgba(0,0,0,0.6);padding:6px 10px;border:1px solid #ff0;border-radius:3px">&#9664; ARCADE</a></div></div>

    <a id="exitBtn" href="Index.html">&#10005; EXIT</a>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');

        // ===== AUDIO =====
        class SFX {
            constructor() { this.ctx = null; }
            init() {
                if (this.ctx) return;
                try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { }
            }
            play(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = () => this.ctx.createOscillator();
                const gn = () => this.ctx.createGain();

                if (type === 'laser') {
                    [0, 0.03, 0.06, 0.09].forEach((d, i) => {
                        const o = osc(), g = gn();
                        o.type = 'square'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(1000 - i * 80, t + d);
                        o.frequency.exponentialRampToValueAtTime(200, t + d + 0.07);
                        g.gain.setValueAtTime(0.06, t + d);
                        g.gain.exponentialRampToValueAtTime(0.001, t + d + 0.07);
                        o.start(t + d); o.stop(t + d + 0.08);
                    });
                }
                if (type === 'tie_explode') {
                    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.5, this.ctx.sampleRate);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 0.6);
                    const src = this.ctx.createBufferSource(), g = gn();
                    src.buffer = buf; src.connect(g); g.connect(this.ctx.destination);
                    g.gain.setValueAtTime(0.2, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                    src.start(t);
                    const o = osc(), g2 = gn();
                    o.type = 'sine'; o.connect(g2); g2.connect(this.ctx.destination);
                    o.frequency.setValueAtTime(120, t);
                    o.frequency.exponentialRampToValueAtTime(30, t + 0.4);
                    g2.gain.setValueAtTime(0.12, t);
                    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                    o.start(t); o.stop(t + 0.4);
                }
                if (type === 'tie_laser') {
                    const o = osc(), g = gn();
                    o.type = 'sawtooth'; o.connect(g); g.connect(this.ctx.destination);
                    o.frequency.setValueAtTime(600, t);
                    o.frequency.exponentialRampToValueAtTime(150, t + 0.12);
                    g.gain.setValueAtTime(0.04, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
                    o.start(t); o.stop(t + 0.12);
                }
                if (type === 'hit') {
                    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 1.5);
                    const src = this.ctx.createBufferSource(), g = gn();
                    src.buffer = buf; src.connect(g); g.connect(this.ctx.destination);
                    g.gain.setValueAtTime(0.15, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                    src.start(t);
                }
                if (type === 'shield_alarm') {
                    [400, 300, 400, 300].forEach((f, i) => {
                        const o = osc(), g = gn();
                        o.type = 'square'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(f, t + i * 0.12);
                        g.gain.setValueAtTime(0.03, t + i * 0.12);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.12 + 0.11);
                        o.start(t + i * 0.12); o.stop(t + i * 0.12 + 0.12);
                    });
                }
                if (type === 'countdown') {
                    const o = osc(), g = gn();
                    o.type = 'sine'; o.connect(g); g.connect(this.ctx.destination);
                    o.frequency.setValueAtTime(600, t);
                    g.gain.setValueAtTime(0.04, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
                    o.start(t); o.stop(t + 0.07);
                }
                if (type === 'go') {
                    [800, 1000, 1200].forEach((f, i) => {
                        const o = osc(), g = gn();
                        o.type = 'sine'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(f, t + i * 0.06);
                        g.gain.setValueAtTime(0.04, t + i * 0.06);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.06 + 0.07);
                        o.start(t + i * 0.06); o.stop(t + i * 0.06 + 0.07);
                    });
                }
                if (type === 'gameover') {
                    [300, 250, 200, 150, 100].forEach((f, i) => {
                        const o = osc(), g = gn();
                        o.type = 'triangle'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(f, t + i * 0.3);
                        g.gain.setValueAtTime(0.06, t + i * 0.3);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.3 + 0.29);
                        o.start(t + i * 0.3); o.stop(t + i * 0.3 + 0.3);
                    });
                }
                if (type === 'victory') {
                    [392, 523, 659, 784, 659, 784, 1047].forEach((f, i) => {
                        const o = osc(), g = gn();
                        o.type = i < 4 ? 'sine' : 'triangle'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(f, t + i * 0.2);
                        g.gain.setValueAtTime(0.06, t + i * 0.2);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.2 + 0.19);
                        o.start(t + i * 0.2); o.stop(t + i * 0.2 + 0.2);
                    });
                }
            }
        }

        const sfx = new SFX();
        const MAX_WAVES = 9;
        let W, H;
        let state = 'start';
        let score = 0, shields = 100, wave = 1;
        let enemies = [], explosions = [], playerLasers = [], enemyLasers = [], particles = [], debris = [];
        let crossX = 0.5, crossY = 0.5;
        let camX = 0, camY = 0;
        let keys = {};
        let spawnTimer = 0, spawnInterval = 1800;
        let killed = 0, waveTarget = 6;
        let maxOnScreen = 4;
        let lastTime = 0;
        let shakeX = 0, shakeY = 0, shakeTimer = 0;
        let gunFlash = 0;

        // Snow particles (replaces stars)
        let snowParticles = [];
        let snowSpeed = 1;

        // Mountains (generated once)
        let mountains = [];
        let mountainsFar = [];

        // Countdown
        let countdownPhase = 0, countdownTimer = 0;
        const CD_DUR = [800, 700, 700, 700, 700, 400];
        const CD_TEXT = ['', 'ALL SPEEDERS REPORT IN', '3', '2', '1', 'ENGAGE!'];
        let victoryTimer = 0;

        // Cockpit flicker
        let cockpitDmgFlash = 0;

        function initSnow() {
            snowParticles = [];
            for (let i = 0; i < 250; i++) {
                snowParticles.push({
                    x: Math.random() * 3 - 0.5,
                    y: Math.random() * 2 - 0.5,
                    z: Math.random() * 3 + 0.5,
                    size: 0.5 + Math.random() * 2.0,
                    drift: 0.3 + Math.random() * 0.5,
                    fall: 0.05 + Math.random() * 0.15,
                });
            }
        }

        function initMountains() {
            // Far mountains (lighter, smaller)
            mountainsFar = [];
            let mx = -0.1;
            while (mx < 1.1) {
                const peak = 0.18 + Math.random() * 0.10;
                const width = 0.06 + Math.random() * 0.12;
                mountainsFar.push({ x: mx, peak: peak, width: width });
                mx += width * 0.6 + Math.random() * 0.04;
            }
            // Near mountains (darker, taller)
            mountains = [];
            mx = -0.1;
            while (mx < 1.1) {
                const peak = 0.12 + Math.random() * 0.14;
                const width = 0.08 + Math.random() * 0.15;
                mountains.push({ x: mx, peak: peak, width: width });
                mx += width * 0.5 + Math.random() * 0.05;
            }
        }

        function resize() {
            W = canvas.width = window.innerWidth * 2;
            H = canvas.height = window.innerHeight * 2;
        }
        window.addEventListener('resize', resize);
        resize();
        initSnow();
        initMountains();

        // ===== DRAWING =====

        function drawHothBackground(dt) {
            // Icy sky gradient - horizon at 35% so we see more ground
            const skyGrad = ctx.createLinearGradient(0, 0, 0, H * 0.38);
            skyGrad.addColorStop(0, '#8aaace');
            skyGrad.addColorStop(0.6, '#c8d8e8');
            skyGrad.addColorStop(1, '#e8eef4');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, W, H * 0.38);

            // Snow ground - starts at horizon
            const groundGrad = ctx.createLinearGradient(0, H * 0.35, 0, H);
            groundGrad.addColorStop(0, '#e0e8f0');
            groundGrad.addColorStop(0.2, '#d8e2ec');
            groundGrad.addColorStop(0.5, '#d0dce8');
            groundGrad.addColorStop(1, '#b8c8d8');
            ctx.fillStyle = groundGrad;
            ctx.fillRect(0, H * 0.35, W, H * 0.65);

            // Horizon haze
            ctx.fillStyle = 'rgba(200, 215, 230, 0.4)';
            ctx.fillRect(0, H * 0.32, W, H * 0.08);

            // Far mountains (lighter blue-white) - sit at horizon
            ctx.fillStyle = '#c8d4e0';
            mountainsFar.forEach(m => {
                const mx = m.x * W;
                const mw = m.width * W;
                const base = H * 0.38;
                const peak = base - m.peak * H * 0.6;
                ctx.beginPath();
                ctx.moveTo(mx - mw * 0.5, base);
                ctx.lineTo(mx - mw * 0.1, peak + H * 0.04);
                ctx.lineTo(mx, peak);
                ctx.lineTo(mx + mw * 0.15, peak + H * 0.03);
                ctx.lineTo(mx + mw * 0.5, base);
                ctx.closePath();
                ctx.fill();
            });

            // Snow caps on far mountains
            ctx.fillStyle = '#e8eef8';
            mountainsFar.forEach(m => {
                const mx = m.x * W;
                const mw = m.width * W;
                const base = H * 0.38;
                const peak = base - m.peak * H * 0.6;
                ctx.beginPath();
                ctx.moveTo(mx - mw * 0.08, peak + H * 0.025);
                ctx.lineTo(mx, peak);
                ctx.lineTo(mx + mw * 0.1, peak + H * 0.02);
                ctx.lineTo(mx + mw * 0.05, peak + H * 0.04);
                ctx.lineTo(mx - mw * 0.05, peak + H * 0.04);
                ctx.closePath();
                ctx.fill();
            });

            // Near mountains (darker blue-gray)
            ctx.fillStyle = '#a0b0c4';
            mountains.forEach(m => {
                const mx = m.x * W;
                const mw = m.width * W;
                const base = H * 0.40;
                const peak = base - m.peak * H * 0.55;
                ctx.beginPath();
                ctx.moveTo(mx - mw * 0.5, base);
                ctx.lineTo(mx - mw * 0.15, peak + H * 0.05);
                ctx.lineTo(mx - mw * 0.05, peak + H * 0.01);
                ctx.lineTo(mx, peak);
                ctx.lineTo(mx + mw * 0.08, peak + H * 0.02);
                ctx.lineTo(mx + mw * 0.5, base);
                ctx.closePath();
                ctx.fill();
            });

            // Snow caps on near mountains
            ctx.fillStyle = '#dce6f0';
            mountains.forEach(m => {
                const mx = m.x * W;
                const mw = m.width * W;
                const base = H * 0.40;
                const peak = base - m.peak * H * 0.55;
                ctx.beginPath();
                ctx.moveTo(mx - mw * 0.06, peak + H * 0.015);
                ctx.lineTo(mx, peak);
                ctx.lineTo(mx + mw * 0.06, peak + H * 0.015);
                ctx.lineTo(mx + mw * 0.03, peak + H * 0.035);
                ctx.lineTo(mx - mw * 0.04, peak + H * 0.03);
                ctx.closePath();
                ctx.fill();
            });

            // Snow particles blowing across
            const spd = state === 'playing' ? 1.2 : 0.5;
            snowParticles.forEach(s => {
                // Drift right and slightly down
                s.x += s.drift * spd * dt;
                s.y += s.fall * spd * dt;

                // Reset when off screen
                if (s.x > 1.5) {
                    s.x = -0.2;
                    s.y = Math.random() * 1.5 - 0.3;
                    s.z = Math.random() * 3 + 0.5;
                }
                if (s.y > 1.2) {
                    s.y = -0.1;
                    s.x = Math.random() * 1.5 - 0.2;
                }

                const sx = s.x * W;
                const sy = s.y * H;
                const sz = s.size * (1 / s.z) * 2;

                if (sx < -20 || sx > W + 20 || sy < -20 || sy > H + 20) return;

                const brightness = Math.min(1, (3 - s.z) / 2);
                ctx.fillStyle = `rgba(255,255,255,${brightness * 0.7})`;
                ctx.beginPath();
                ctx.arc(sx, sy, sz, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawProbeDroid(e) {
            // 3D-ish projection
            const depth = e.z;
            const scale = 1 / depth;
            const sx = (e.x - 0.5) * W * scale + W * 0.5;
            const sy = (e.y - 0.5) * H * scale + H * 0.5;
            const sz = Math.min(W, H) * 0.04 * scale;

            if (sz < 2 || sx < -100 || sx > W + 100 || sy < -100 || sy > H + 100) return;

            e.screenX = sx; e.screenY = sy; e.screenSize = sz;

            const flash = e.flash > 0;

            ctx.save();
            ctx.translate(sx, sy);

            // Antenna on top
            ctx.strokeStyle = flash ? '#ccccdd' : '#555566';
            ctx.lineWidth = Math.max(1, sz * 0.04);
            ctx.beginPath();
            ctx.moveTo(0, -sz * 0.7);
            ctx.lineTo(0, -sz * 1.4);
            ctx.stroke();
            // Antenna tip
            ctx.fillStyle = flash ? '#ffffff' : '#888899';
            ctx.beginPath();
            ctx.arc(0, -sz * 1.4, sz * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Main body (dark metallic sphere)
            const bodyGrad = ctx.createRadialGradient(
                -sz * 0.15, -sz * 0.15, 0,
                0, 0, sz * 0.7
            );
            bodyGrad.addColorStop(0, flash ? '#aaaabc' : '#4a4a5c');
            bodyGrad.addColorStop(0.5, flash ? '#777788' : '#2a2a3c');
            bodyGrad.addColorStop(1, flash ? '#555566' : '#1a1a2c');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.arc(0, 0, sz * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = flash ? '#9999aa' : '#3a3a4c';
            ctx.lineWidth = Math.max(1, sz * 0.03);
            ctx.stroke();

            // Red scanning eye (pulsing)
            const eyePulse = 0.5 + Math.sin(Date.now() * 0.006 + e.wobblePhase) * 0.5;
            ctx.fillStyle = `rgba(255, ${Math.floor(30 + eyePulse * 40)}, ${Math.floor(20 + eyePulse * 20)}, ${0.7 + eyePulse * 0.3})`;
            ctx.shadowColor = '#ff2020';
            ctx.shadowBlur = 8 + eyePulse * 6;
            ctx.beginPath();
            ctx.arc(0, -sz * 0.1, sz * 0.15, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Inner eye highlight
            ctx.fillStyle = `rgba(255, 150, 100, ${eyePulse * 0.6})`;
            ctx.beginPath();
            ctx.arc(-sz * 0.04, -sz * 0.14, sz * 0.06, 0, Math.PI * 2);
            ctx.fill();

            // Sensor panel lines on body
            ctx.strokeStyle = flash ? '#888899' : '#3a3a4c';
            ctx.lineWidth = Math.max(0.5, sz * 0.02);
            // Horizontal band
            ctx.beginPath();
            ctx.arc(0, 0, sz * 0.55, 0.2, Math.PI - 0.2);
            ctx.stroke();

            // Dangling sensor arms (3-4 thin lines hanging down)
            const arms = [
                { x: -sz * 0.3, len: sz * 1.2 },
                { x: -sz * 0.05, len: sz * 1.5 },
                { x: sz * 0.2, len: sz * 1.3 },
                { x: sz * 0.35, len: sz * 1.0 },
            ];
            arms.forEach((arm, i) => {
                const wobble = Math.sin(Date.now() * 0.003 + i * 1.5 + e.wobblePhase) * sz * 0.08;
                ctx.strokeStyle = flash ? '#aaaabc' : '#444455';
                ctx.lineWidth = Math.max(1, sz * 0.03);
                ctx.beginPath();
                ctx.moveTo(arm.x, sz * 0.5);
                ctx.quadraticCurveTo(arm.x + wobble * 0.5, sz * 0.5 + arm.len * 0.5, arm.x + wobble, sz * 0.5 + arm.len);
                ctx.stroke();
                // Small sensor bulb at end
                ctx.fillStyle = flash ? '#aaaabc' : '#555566';
                ctx.beginPath();
                ctx.arc(arm.x + wobble, sz * 0.5 + arm.len, sz * 0.05, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        function drawWampa(e) {
            // 3D-ish projection
            const depth = e.z;
            const scale = 1 / depth;
            const sx = (e.x - 0.5) * W * scale + W * 0.5;
            const sy = (e.y - 0.5) * H * scale + H * 0.5;
            const sz = Math.min(W, H) * 0.06 * scale; // Bigger than probe droids

            if (sz < 2 || sx < -100 || sx > W + 100 || sy < -100 || sy > H + 100) return;

            e.screenX = sx; e.screenY = sy; e.screenSize = sz;

            const flash = e.flash > 0;

            ctx.save();
            ctx.translate(sx, sy);

            // Big white furry body (oval)
            const bodyGrad = ctx.createRadialGradient(
                -sz * 0.1, -sz * 0.1, 0,
                0, 0, sz * 1.0
            );
            bodyGrad.addColorStop(0, flash ? '#ffffff' : '#e8e4e0');
            bodyGrad.addColorStop(0.5, flash ? '#eeeef0' : '#c8c4bc');
            bodyGrad.addColorStop(1, flash ? '#ddddee' : '#a09890');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, sz * 0.8, sz * 1.1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Fur texture lines
            ctx.strokeStyle = flash ? '#ffffff' : 'rgba(180, 175, 165, 0.4)';
            ctx.lineWidth = Math.max(0.5, sz * 0.015);
            for (let i = 0; i < 8; i++) {
                const fx = (Math.random() - 0.5) * sz * 1.2;
                const fy = (Math.random() - 0.5) * sz * 1.8;
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.lineTo(fx + (Math.random() - 0.5) * sz * 0.2, fy + sz * 0.15);
                ctx.stroke();
            }

            // Arms raised up (threatening pose)
            // Left arm
            ctx.fillStyle = flash ? '#eeeef0' : '#d0ccc4';
            ctx.beginPath();
            ctx.moveTo(-sz * 0.6, -sz * 0.3);
            ctx.lineTo(-sz * 1.1, -sz * 1.2);
            ctx.lineTo(-sz * 0.85, -sz * 1.3);
            ctx.lineTo(-sz * 0.4, -sz * 0.5);
            ctx.closePath();
            ctx.fill();
            // Left claw
            ctx.strokeStyle = flash ? '#ffffff' : '#888080';
            ctx.lineWidth = Math.max(1, sz * 0.04);
            ctx.beginPath();
            ctx.moveTo(-sz * 1.0, -sz * 1.25);
            ctx.lineTo(-sz * 1.15, -sz * 1.45);
            ctx.moveTo(-sz * 0.93, -sz * 1.28);
            ctx.lineTo(-sz * 1.0, -sz * 1.48);
            ctx.moveTo(-sz * 0.87, -sz * 1.3);
            ctx.lineTo(-sz * 0.88, -sz * 1.47);
            ctx.stroke();

            // Right arm
            ctx.fillStyle = flash ? '#eeeef0' : '#d0ccc4';
            ctx.beginPath();
            ctx.moveTo(sz * 0.6, -sz * 0.3);
            ctx.lineTo(sz * 1.1, -sz * 1.1);
            ctx.lineTo(sz * 0.85, -sz * 1.2);
            ctx.lineTo(sz * 0.4, -sz * 0.5);
            ctx.closePath();
            ctx.fill();
            // Right claw
            ctx.strokeStyle = flash ? '#ffffff' : '#888080';
            ctx.lineWidth = Math.max(1, sz * 0.04);
            ctx.beginPath();
            ctx.moveTo(sz * 1.0, -sz * 1.15);
            ctx.lineTo(sz * 1.15, -sz * 1.35);
            ctx.moveTo(sz * 0.93, -sz * 1.18);
            ctx.lineTo(sz * 1.0, -sz * 1.38);
            ctx.moveTo(sz * 0.87, -sz * 1.2);
            ctx.lineTo(sz * 0.88, -sz * 1.37);
            ctx.stroke();

            // Head
            ctx.fillStyle = flash ? '#f0f0f4' : '#d8d4cc';
            ctx.beginPath();
            ctx.ellipse(0, -sz * 0.85, sz * 0.45, sz * 0.4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Horns
            ctx.fillStyle = flash ? '#ddddcc' : '#a09880';
            // Left horn
            ctx.beginPath();
            ctx.moveTo(-sz * 0.3, -sz * 1.05);
            ctx.lineTo(-sz * 0.55, -sz * 1.35);
            ctx.lineTo(-sz * 0.2, -sz * 1.1);
            ctx.closePath();
            ctx.fill();
            // Right horn
            ctx.beginPath();
            ctx.moveTo(sz * 0.3, -sz * 1.05);
            ctx.lineTo(sz * 0.55, -sz * 1.35);
            ctx.lineTo(sz * 0.2, -sz * 1.1);
            ctx.closePath();
            ctx.fill();

            // Yellow eyes
            ctx.fillStyle = '#ffdd00';
            ctx.shadowColor = '#ffcc00';
            ctx.shadowBlur = 4;
            ctx.beginPath();
            ctx.ellipse(-sz * 0.15, -sz * 0.9, sz * 0.08, sz * 0.06, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(sz * 0.15, -sz * 0.9, sz * 0.08, sz * 0.06, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(-sz * 0.15, -sz * 0.9, sz * 0.035, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(sz * 0.15, -sz * 0.9, sz * 0.035, 0, Math.PI * 2);
            ctx.fill();

            // Dark mouth
            ctx.fillStyle = flash ? '#664444' : '#3a2020';
            ctx.beginPath();
            ctx.ellipse(0, -sz * 0.7, sz * 0.2, sz * 0.1, 0, 0, Math.PI * 2);
            ctx.fill();
            // Fangs
            ctx.fillStyle = '#eee8e0';
            ctx.beginPath();
            ctx.moveTo(-sz * 0.1, -sz * 0.7);
            ctx.lineTo(-sz * 0.07, -sz * 0.55);
            ctx.lineTo(-sz * 0.04, -sz * 0.7);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(sz * 0.1, -sz * 0.7);
            ctx.lineTo(sz * 0.07, -sz * 0.55);
            ctx.lineTo(sz * 0.04, -sz * 0.7);
            ctx.fill();

            ctx.restore();
        }

        function drawPlayerLaser(b) {
            const depth = b.z;
            if (depth < 0.15) return;
            const scale = 1 / depth;
            const sx = (b.x - 0.5) * W * scale + W * 0.5;
            const sy = (b.y - 0.5) * H * scale + H * 0.5;

            const trailDt = 0.015;
            const prevZ = b.z - b.vz * trailDt;
            if (prevZ < 0.1) return;
            const prevScale = 1 / prevZ;
            const prevX = ((b.x - b.vx * trailDt) - 0.5) * W * prevScale + W * 0.5;
            const prevY = ((b.y - b.vy * trailDt) - 0.5) * H * prevScale + H * 0.5;

            // Orange glow (snowspeeder lasers)
            ctx.shadowColor = '#ff8844';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#ff8844';
            ctx.lineWidth = Math.max(2.5, 5 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();

            // Bright orange core
            ctx.strokeStyle = '#ffaa66';
            ctx.lineWidth = Math.max(1.5, 3 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();

            // Hot white-orange center
            ctx.strokeStyle = '#ffddbb';
            ctx.lineWidth = Math.max(0.8, 1.5 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Leading dot
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(sx, sy, Math.max(2, 3 * scale), 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEnemyLaser(b) {
            const depth = b.z;
            if (depth < 0.1) return;
            const scale = 1 / depth;
            const sx = (b.x - 0.5) * W * scale + W * 0.5;
            const sy = (b.y - 0.5) * H * scale + H * 0.5;

            const trailDt = 0.025;
            const prevZ = b.z - b.vz * trailDt;
            if (prevZ < 0.05 || prevZ > 8) return;
            const prevScale = 1 / prevZ;
            const prevX = ((b.x - b.vx * trailDt) - 0.5) * W * prevScale + W * 0.5;
            const prevY = ((b.y - b.vy * trailDt) - 0.5) * H * prevScale + H * 0.5;

            // Check if this is a wampa ice boulder projectile
            const isIce = b.isIce;

            if (isIce) {
                // Blue-white ice boulder
                ctx.shadowColor = '#88ccff';
                ctx.shadowBlur = 10;
                ctx.strokeStyle = '#88ccff';
                ctx.lineWidth = Math.max(3, 6 * scale);
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(prevX, prevY);
                ctx.stroke();

                ctx.strokeStyle = '#bbddff';
                ctx.lineWidth = Math.max(2, 4 * scale);
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(prevX, prevY);
                ctx.stroke();

                ctx.strokeStyle = '#eef4ff';
                ctx.lineWidth = Math.max(1, 2 * scale);
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(prevX, prevY);
                ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#ddeeff';
                ctx.beginPath();
                ctx.arc(sx, sy, Math.max(2.5, 4 * scale), 0, Math.PI * 2);
                ctx.fill();
            } else {
                // Red blaster bolts (probe droid)
                ctx.shadowColor = '#ff2020';
                ctx.shadowBlur = 10;
                ctx.strokeStyle = '#ff2020';
                ctx.lineWidth = Math.max(2.5, 5 * scale);
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(prevX, prevY);
                ctx.stroke();

                ctx.strokeStyle = '#ff6060';
                ctx.lineWidth = Math.max(1.5, 3 * scale);
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(prevX, prevY);
                ctx.stroke();

                ctx.strokeStyle = '#ffaaaa';
                ctx.lineWidth = Math.max(0.8, 1.5 * scale);
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(prevX, prevY);
                ctx.stroke();
                ctx.shadowBlur = 0;

                ctx.fillStyle = '#ffcccc';
                ctx.beginPath();
                ctx.arc(sx, sy, Math.max(1.5, 2.5 * scale), 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawExplosion(ex) {
            const depth = ex.z;
            if (depth < 0.1) return;
            const scale = 1 / depth;
            const sx = (ex.x - 0.5) * W * scale + W * 0.5;
            const sy = (ex.y - 0.5) * H * scale + H * 0.5;
            const p = ex.progress;
            const r = (10 + p * 50) * scale;

            if (p < 0.5) {
                const fa = 1 - p * 2;
                const fireGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, r);
                fireGrad.addColorStop(0, `rgba(255,255,200,${fa})`);
                fireGrad.addColorStop(0.3, `rgba(255,150,30,${fa * 0.8})`);
                fireGrad.addColorStop(0.6, `rgba(255,60,10,${fa * 0.5})`);
                fireGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = fireGrad;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.strokeStyle = `rgba(255,100,20,${Math.max(0, 0.6 - p)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(sx, sy, r * 1.3, 0, Math.PI * 2);
            ctx.stroke();

            for (let i = 0; i < 8; i++) {
                const a = (i / 8) * Math.PI * 2 + ex.spin;
                const dist = r * (0.5 + p * 1.5);
                const alpha = Math.max(0, 1 - p * 1.3);
                ctx.fillStyle = i % 2 === 0
                    ? `rgba(255,200,50,${alpha})`
                    : `rgba(255,100,20,${alpha})`;
                ctx.beginPath();
                ctx.arc(sx + Math.cos(a) * dist, sy + Math.sin(a) * dist, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawDebris(d) {
            const depth = d.z;
            if (depth < 0.1) return;
            const scale = 1 / depth;
            const sx = (d.x - 0.5) * W * scale + W * 0.5;
            const sy = (d.y - 0.5) * H * scale + H * 0.5;
            const sz = d.size * scale;

            ctx.save();
            ctx.translate(sx, sy);
            ctx.rotate(d.rot);
            ctx.fillStyle = `rgba(100,100,110,${d.alpha})`;
            ctx.fillRect(-sz, -sz * 0.3, sz * 2, sz * 0.6);
            ctx.restore();
        }

        function drawCrosshair() {
            const cx = crossX * W, cy = crossY * H;
            const r = Math.min(W, H) * 0.025;

            // Orange targeting brackets
            ctx.strokeStyle = 'rgba(255,136,68,0.6)';
            ctx.lineWidth = 2;
            const s = r * 1.3;

            ctx.beginPath();
            ctx.moveTo(cx - s, cy - s); ctx.lineTo(cx - s + r * 0.4, cy - s);
            ctx.moveTo(cx - s, cy - s); ctx.lineTo(cx - s, cy - s + r * 0.4);
            ctx.moveTo(cx + s, cy - s); ctx.lineTo(cx + s - r * 0.4, cy - s);
            ctx.moveTo(cx + s, cy - s); ctx.lineTo(cx + s, cy - s + r * 0.4);
            ctx.moveTo(cx - s, cy + s); ctx.lineTo(cx - s + r * 0.4, cy + s);
            ctx.moveTo(cx - s, cy + s); ctx.lineTo(cx - s, cy + s - r * 0.4);
            ctx.moveTo(cx + s, cy + s); ctx.lineTo(cx + s - r * 0.4, cy + s);
            ctx.moveTo(cx + s, cy + s); ctx.lineTo(cx + s, cy + s - r * 0.4);
            ctx.stroke();

            // Center dot
            ctx.fillStyle = 'rgba(255,136,68,0.7)';
            ctx.beginPath();
            ctx.arc(cx, cy, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // ===== COCKPIT HUD =====
        function drawCockpit() {
            const s = Math.min(W, H);

            // === CANOPY FRAME (slightly lighter gray for snow theme) ===
            ctx.fillStyle = '#151520';
            ctx.fillRect(0, 0, W, H * 0.06);
            ctx.strokeStyle = '#2a2a38';
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, H * 0.06); ctx.lineTo(W, H * 0.06); ctx.stroke();

            // === LEFT CANOPY FRAME ===
            ctx.fillStyle = '#151520';
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(W * 0.12, H * 0.04);
            ctx.lineTo(W * 0.08, H * 0.62);
            ctx.lineTo(W * 0.22, H * 0.64);
            ctx.lineTo(W * 0.28, H * 0.68);
            ctx.lineTo(0, H * 0.72);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#222230';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(W * 0.12, H * 0.04);
            ctx.lineTo(W * 0.08, H * 0.62);
            ctx.lineTo(W * 0.22, H * 0.64);
            ctx.lineTo(W * 0.28, H * 0.68);
            ctx.stroke();

            // === RIGHT CANOPY FRAME ===
            ctx.fillStyle = '#151520';
            ctx.beginPath();
            ctx.moveTo(W, 0);
            ctx.lineTo(W * 0.88, H * 0.04);
            ctx.lineTo(W * 0.92, H * 0.62);
            ctx.lineTo(W * 0.78, H * 0.64);
            ctx.lineTo(W * 0.72, H * 0.68);
            ctx.lineTo(W, H * 0.72);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#222230';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(W * 0.88, H * 0.04);
            ctx.lineTo(W * 0.92, H * 0.62);
            ctx.lineTo(W * 0.78, H * 0.64);
            ctx.lineTo(W * 0.72, H * 0.68);
            ctx.stroke();

            // === MAIN DASHBOARD (gray/military theme) ===
            const dashTop = H * 0.64;

            const dashGrad = ctx.createLinearGradient(0, dashTop, 0, H);
            dashGrad.addColorStop(0, '#1a1a20');
            dashGrad.addColorStop(0.15, '#1e1e28');
            dashGrad.addColorStop(0.5, '#161620');
            dashGrad.addColorStop(1, '#101018');
            ctx.fillStyle = dashGrad;
            ctx.beginPath();
            ctx.moveTo(0, H * 0.72);
            ctx.lineTo(W * 0.28, H * 0.68);
            ctx.lineTo(W * 0.38, dashTop + H * 0.04);
            ctx.lineTo(W * 0.50, dashTop);
            ctx.lineTo(W * 0.62, dashTop + H * 0.04);
            ctx.lineTo(W * 0.72, H * 0.68);
            ctx.lineTo(W, H * 0.72);
            ctx.lineTo(W, H);
            ctx.lineTo(0, H);
            ctx.closePath();
            ctx.fill();

            // Dash top edge highlight
            ctx.strokeStyle = '#333345';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, H * 0.72);
            ctx.lineTo(W * 0.28, H * 0.68);
            ctx.lineTo(W * 0.38, dashTop + H * 0.04);
            ctx.lineTo(W * 0.50, dashTop);
            ctx.lineTo(W * 0.62, dashTop + H * 0.04);
            ctx.lineTo(W * 0.72, H * 0.68);
            ctx.lineTo(W, H * 0.72);
            ctx.stroke();

            // Cockpit damage flash overlay (white-blue for cold damage)
            if (cockpitDmgFlash > 0) {
                ctx.fillStyle = `rgba(180,220,255,${cockpitDmgFlash * 0.15})`;
                ctx.fillRect(0, 0, W, H);
            }

            // === LEFT INSTRUMENT PANEL ===
            const lpx = W * 0.03;
            const lpy = H * 0.70;
            const lpw = W * 0.24;
            const lph = H * 0.26;

            ctx.save();
            ctx.translate(lpx + lpw * 0.5, lpy + lph * 0.5);
            ctx.rotate(-0.12);

            ctx.fillStyle = '#121218';
            ctx.fillRect(-lpw * 0.5, -lph * 0.5, lpw, lph);
            ctx.strokeStyle = '#333345';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(-lpw * 0.5, -lph * 0.5, lpw, lph);

            const panelSections = [
                { x: -lpw * 0.45, y: -lph * 0.45, w: lpw * 0.42, h: lph * 0.35, border: '#604020' },
                { x: lpw * 0.03, y: -lph * 0.45, w: lpw * 0.42, h: lph * 0.35, border: '#383848' },
                { x: -lpw * 0.45, y: -lph * 0.02, w: lpw * 0.9, h: lph * 0.48, border: '#604020' },
            ];

            panelSections.forEach(ps => {
                ctx.fillStyle = '#0a0a12';
                ctx.fillRect(ps.x, ps.y, ps.w, ps.h);
                ctx.strokeStyle = ps.border;
                ctx.lineWidth = 1;
                ctx.strokeRect(ps.x, ps.y, ps.w, ps.h);
            });

            // Button rows - orange illuminated buttons
            const t = Date.now() * 0.001;
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 4; col++) {
                    const bx = -lpw * 0.40 + col * lpw * 0.22;
                    const by = -lph * 0.38 + row * lph * 0.09;
                    const bsz = s * 0.008;
                    const lit = Math.sin(t * 2 + row * 1.5 + col * 0.7) > 0.2;
                    ctx.fillStyle = lit ? '#e8c080' : '#3a3020';
                    ctx.shadowColor = lit ? '#ffa040' : 'transparent';
                    ctx.shadowBlur = lit ? 4 : 0;
                    ctx.fillRect(bx - bsz, by - bsz * 0.6, bsz * 2, bsz * 1.2);
                    ctx.shadowBlur = 0;
                }
            }

            // Large button block
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 5; col++) {
                    const bx = -lpw * 0.40 + col * lpw * 0.18;
                    const by = lph * 0.05 + row * lph * 0.13;
                    const bsz = s * 0.01;
                    const lit = Math.sin(t * 1.5 + row * 2.3 + col * 1.1) > 0;
                    ctx.fillStyle = lit ? '#e0c090' : '#2a2518';
                    ctx.shadowColor = lit ? '#ffa040' : 'transparent';
                    ctx.shadowBlur = lit ? 5 : 0;
                    ctx.fillRect(bx - bsz, by - bsz * 0.7, bsz * 2, bsz * 1.4);
                    ctx.shadowBlur = 0;
                }
            }

            // Orange indicator lights (instead of red)
            [-lph * 0.35, -lph * 0.20, lph * 0.38].forEach((iy, i) => {
                const lit = Math.sin(t * 3 + i * 2) > 0.3;
                ctx.fillStyle = lit ? '#ff8830' : '#401808';
                ctx.shadowColor = lit ? '#ff8830' : 'transparent';
                ctx.shadowBlur = lit ? 5 : 0;
                ctx.beginPath();
                ctx.arc(lpw * 0.38, iy, s * 0.005, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Blue indicator lights
            [-lph * 0.28, lph * 0.10].forEach((iy, i) => {
                const lit = Math.sin(t * 2.5 + i * 3) > 0;
                ctx.fillStyle = lit ? '#4080ff' : '#101840';
                ctx.shadowColor = lit ? '#4080ff' : 'transparent';
                ctx.shadowBlur = lit ? 4 : 0;
                ctx.beginPath();
                ctx.arc(-lpw * 0.42, iy, s * 0.004, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            ctx.restore();

            // === RIGHT INSTRUMENT PANEL ===
            const rpx = W * 0.73;
            const rpy = H * 0.70;

            ctx.save();
            ctx.translate(rpx + lpw * 0.5, rpy + lph * 0.5);
            ctx.rotate(0.12);

            ctx.fillStyle = '#121218';
            ctx.fillRect(-lpw * 0.5, -lph * 0.5, lpw, lph);
            ctx.strokeStyle = '#333345';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(-lpw * 0.5, -lph * 0.5, lpw, lph);

            const rpanels = [
                { x: -lpw * 0.45, y: -lph * 0.45, w: lpw * 0.42, h: lph * 0.35, border: '#383848' },
                { x: lpw * 0.03, y: -lph * 0.45, w: lpw * 0.42, h: lph * 0.35, border: '#604020' },
                { x: -lpw * 0.45, y: -lph * 0.02, w: lpw * 0.9, h: lph * 0.48, border: '#383848' },
            ];

            rpanels.forEach(ps => {
                ctx.fillStyle = '#0a0a12';
                ctx.fillRect(ps.x, ps.y, ps.w, ps.h);
                ctx.strokeStyle = ps.border;
                ctx.lineWidth = 1;
                ctx.strokeRect(ps.x, ps.y, ps.w, ps.h);
            });

            // Right panel buttons
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 4; col++) {
                    const bx = -lpw * 0.40 + col * lpw * 0.22;
                    const by = -lph * 0.38 + row * lph * 0.09;
                    const bsz = s * 0.008;
                    const lit = Math.sin(t * 2.2 + row * 1.8 + col * 0.9) > 0.2;
                    ctx.fillStyle = lit ? '#e8c080' : '#3a3020';
                    ctx.shadowColor = lit ? '#ffa040' : 'transparent';
                    ctx.shadowBlur = lit ? 4 : 0;
                    ctx.fillRect(bx - bsz, by - bsz * 0.6, bsz * 2, bsz * 1.2);
                    ctx.shadowBlur = 0;
                }
            }

            // Right bottom buttons
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 3; col++) {
                    const bx = -lpw * 0.35 + col * lpw * 0.25;
                    const by = lph * 0.08 + row * lph * 0.16;
                    const bsz = s * 0.012;
                    const lit = Math.sin(t * 1.8 + row * 2.5 + col * 1.3) > 0.1;
                    ctx.fillStyle = lit ? '#e0c090' : '#2a2518';
                    ctx.shadowColor = lit ? '#ffa040' : 'transparent';
                    ctx.shadowBlur = lit ? 5 : 0;
                    ctx.fillRect(bx - bsz, by - bsz * 0.7, bsz * 2, bsz * 1.4);
                    ctx.shadowBlur = 0;
                }
            }

            // Orange indicators
            [lph * 0.02, lph * 0.35].forEach((iy, i) => {
                const lit = Math.sin(t * 2.8 + i * 1.7) > 0.3;
                ctx.fillStyle = lit ? '#ff8830' : '#401808';
                ctx.shadowColor = lit ? '#ff8830' : 'transparent';
                ctx.shadowBlur = lit ? 5 : 0;
                ctx.beginPath();
                ctx.arc(lpw * 0.38, iy, s * 0.005, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Blue indicators
            [-lph * 0.40, -lph * 0.15].forEach((iy, i) => {
                const lit = Math.sin(t * 3.1 + i * 2.1) > 0;
                ctx.fillStyle = lit ? '#4080ff' : '#101840';
                ctx.shadowColor = lit ? '#4080ff' : 'transparent';
                ctx.shadowBlur = lit ? 4 : 0;
                ctx.beginPath();
                ctx.arc(lpw * 0.42, iy, s * 0.004, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            ctx.restore();

            // === CENTER TARGETING DISPLAY ===
            const tdx = W * 0.35;
            const tdy = dashTop + H * 0.01;
            const tdw = W * 0.30;
            const tdh = H * 0.12;

            // Display housing
            ctx.fillStyle = '#0c0c16';
            ctx.beginPath();
            ctx.moveTo(tdx - tdw * 0.05, tdy - tdh * 0.08);
            ctx.lineTo(tdx + tdw + tdw * 0.05, tdy - tdh * 0.08);
            ctx.lineTo(tdx + tdw + tdw * 0.02, tdy + tdh + tdh * 0.05);
            ctx.lineTo(tdx - tdw * 0.02, tdy + tdh + tdh * 0.05);
            ctx.closePath();
            ctx.fill();

            // Display bezel
            ctx.strokeStyle = '#333345';
            ctx.lineWidth = 2;
            ctx.strokeRect(tdx, tdy, tdw, tdh);

            // Screen background
            ctx.fillStyle = '#040810';
            ctx.fillRect(tdx, tdy, tdw, tdh);

            // Orange grid lines (targeting computer)
            ctx.strokeStyle = 'rgba(200,120,40,0.25)';
            ctx.lineWidth = 0.8;
            for (let i = 1; i < 6; i++) {
                const gy = tdy + (i / 6) * tdh;
                ctx.beginPath();
                ctx.moveTo(tdx, gy);
                ctx.lineTo(tdx + tdw, gy);
                ctx.stroke();
            }
            for (let i = 1; i < 8; i++) {
                const gx = tdx + (i / 8) * tdw;
                ctx.beginPath();
                ctx.moveTo(gx, tdy);
                ctx.lineTo(gx, tdy + tdh);
                ctx.stroke();
            }

            // Perspective lines
            ctx.strokeStyle = 'rgba(220,160,40,0.35)';
            ctx.lineWidth = 1;
            const vcx = tdx + tdw * 0.5, vcy = tdy + tdh * 0.35;
            ctx.beginPath();
            ctx.moveTo(tdx, tdy + tdh); ctx.lineTo(vcx, vcy); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(tdx, tdy + tdh * 0.7); ctx.lineTo(vcx, vcy); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(tdx + tdw, tdy + tdh); ctx.lineTo(vcx, vcy); ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(tdx + tdw, tdy + tdh * 0.7); ctx.lineTo(vcx, vcy); ctx.stroke();

            // Horizon line
            ctx.strokeStyle = 'rgba(220,160,40,0.5)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(tdx, vcy);
            ctx.lineTo(tdx + tdw, vcy);
            ctx.stroke();

            // Center targeting triangle
            ctx.strokeStyle = 'rgba(200,140,60,0.6)';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(vcx, vcy - tdh * 0.15);
            ctx.lineTo(vcx - tdw * 0.08, vcy + tdh * 0.1);
            ctx.lineTo(vcx + tdw * 0.08, vcy + tdh * 0.1);
            ctx.closePath();
            ctx.stroke();

            // Enemy blips on targeting display
            enemies.forEach(e => {
                if (!e.alive) return;
                const bx = tdx + e.x * tdw;
                const by = tdy + e.y * tdh;
                if (bx > tdx && bx < tdx + tdw && by > tdy && by < tdy + tdh) {
                    ctx.fillStyle = e.isWampa ? 'rgba(255,200,60,0.8)' : 'rgba(255,60,60,0.8)';
                    ctx.beginPath();
                    ctx.arc(bx, by, e.isWampa ? 3.5 : 2.5, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Display text (orange)
            ctx.fillStyle = 'rgba(200,120,60,0.7)';
            ctx.font = `${s * 0.007}px 'Press Start 2P'`;
            ctx.textAlign = 'left';
            ctx.fillText('TRGT:' + enemies.filter(e => e.alive).length, tdx + 4, tdy + tdh - 4);
            ctx.textAlign = 'right';
            ctx.fillText('RNG:' + (enemies.length > 0 ? Math.floor(enemies[0].z * 100) : '---'), tdx + tdw - 4, tdy + tdh - 4);

            // === OVERHEAD LIGHTS (orange-white) ===
            const lightY = dashTop - H * 0.01;
            [-0.08, -0.03, 0.03, 0.08].forEach((ox, i) => {
                const lx = W * 0.5 + ox * W;
                const pulse = Math.sin(t * 0.5 + i) * 0.15 + 0.85;
                ctx.fillStyle = `rgba(255,180,120,${pulse * 0.8})`;
                ctx.shadowColor = '#ffa060';
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.arc(lx, lightY, s * 0.004, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // === DIALS / KNOBS ===
            [-0.04, 0, 0.04].forEach((ox, i) => {
                const kx = W * 0.5 + ox * W;
                const ky = tdy + tdh + H * 0.04;
                const kr = s * 0.012;
                const kGrad = ctx.createRadialGradient(kx - kr * 0.2, ky - kr * 0.2, 0, kx, ky, kr);
                kGrad.addColorStop(0, '#5a5a68');
                kGrad.addColorStop(1, '#2a2a32');
                ctx.fillStyle = kGrad;
                ctx.beginPath();
                ctx.arc(kx, ky, kr, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#3a3a48';
                ctx.lineWidth = 1;
                ctx.stroke();
                const kAngle = t * 0.3 + i * 2;
                ctx.strokeStyle = '#888';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(kx, ky);
                ctx.lineTo(kx + Math.cos(kAngle) * kr * 0.7, ky + Math.sin(kAngle) * kr * 0.7);
                ctx.stroke();
            });

            // === FLIGHT STICK ===
            const stickX = W * 0.5;
            const stickY = H * 0.90;
            const stickH = H * 0.08;

            ctx.fillStyle = '#1a1a22';
            ctx.beginPath();
            ctx.moveTo(stickX - s * 0.035, stickY + stickH);
            ctx.lineTo(stickX + s * 0.035, stickY + stickH);
            ctx.lineTo(stickX + s * 0.025, stickY + stickH - H * 0.03);
            ctx.lineTo(stickX - s * 0.025, stickY + stickH - H * 0.03);
            ctx.closePath();
            ctx.fill();

            const stickLean = (crossX - 0.5) * 0.15;
            ctx.save();
            ctx.translate(stickX, stickY + stickH);
            ctx.rotate(stickLean);

            ctx.fillStyle = '#222230';
            ctx.fillRect(-s * 0.008, -stickH, s * 0.016, stickH);
            ctx.strokeStyle = '#3a3a48';
            ctx.lineWidth = 1;
            ctx.strokeRect(-s * 0.008, -stickH, s * 0.016, stickH);

            const gripGrad = ctx.createLinearGradient(-s * 0.015, -stickH - s * 0.02, s * 0.015, -stickH - s * 0.02);
            gripGrad.addColorStop(0, '#2a2a35');
            gripGrad.addColorStop(0.5, '#3a3a45');
            gripGrad.addColorStop(1, '#2a2a35');
            ctx.fillStyle = gripGrad;
            ctx.beginPath();
            ctx.moveTo(-s * 0.014, -stickH + s * 0.01);
            ctx.lineTo(-s * 0.016, -stickH - s * 0.025);
            ctx.quadraticCurveTo(-s * 0.016, -stickH - s * 0.035, 0, -stickH - s * 0.038);
            ctx.quadraticCurveTo(s * 0.016, -stickH - s * 0.035, s * 0.016, -stickH - s * 0.025);
            ctx.lineTo(s * 0.014, -stickH + s * 0.01);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#3a3a4d';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Trigger button
            ctx.fillStyle = '#ff6620';
            ctx.beginPath();
            ctx.arc(0, -stickH - s * 0.015, s * 0.004, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();

            // === SMALL SIDE DISPLAY (shield) ===
            const sdx = W * 0.37;
            const sdy = H * 0.84;
            const sdw = W * 0.08;
            const sdh = H * 0.08;
            ctx.fillStyle = '#040810';
            ctx.fillRect(sdx, sdy, sdw, sdh);
            ctx.strokeStyle = '#333345';
            ctx.lineWidth = 1;
            ctx.strokeRect(sdx, sdy, sdw, sdh);

            // Mini grid
            ctx.strokeStyle = 'rgba(200,120,40,0.2)';
            ctx.lineWidth = 0.5;
            for (let i = 1; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(sdx, sdy + i * sdh / 4);
                ctx.lineTo(sdx + sdw, sdy + i * sdh / 4);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(sdx + i * sdw / 4, sdy);
                ctx.lineTo(sdx + i * sdw / 4, sdy + sdh);
                ctx.stroke();
            }

            // Shield display
            const shPct = shields / 100;
            const shColor = shPct > 0.5 ? '#ff8844' : (shPct > 0.25 ? '#ffaa20' : '#ff3030');
            ctx.fillStyle = shColor;
            ctx.globalAlpha = 0.7;
            ctx.fillRect(sdx + 3, sdy + sdh - sdh * shPct, sdw - 6, sdh * shPct);
            ctx.globalAlpha = 1;

            ctx.fillStyle = 'rgba(200,120,60,0.5)';
            ctx.font = `${s * 0.006}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText('SHLD', sdx + sdw * 0.5, sdy + s * 0.01);

            if (shields <= 25 && Math.floor(Date.now() / 300) % 2 === 0) {
                ctx.fillStyle = '#ff2020';
                ctx.font = `${s * 0.007}px 'Press Start 2P'`;
                ctx.fillText('LOW', sdx + sdw * 0.5, sdy + sdh * 0.5);
            }

            // === SMALL BUTTONS next to stick ===
            const rbx = W * 0.56;
            for (let row = 0; row < 2; row++) {
                for (let col = 0; col < 2; col++) {
                    const bx = rbx + col * s * 0.025;
                    const by = sdy + H * 0.02 + row * s * 0.025;
                    const bsz = s * 0.009;
                    const lit = Math.sin(t * 1.7 + row * 3 + col * 2) > 0;
                    ctx.fillStyle = lit ? '#d8b080' : '#2a2518';
                    ctx.shadowColor = lit ? '#ffa040' : 'transparent';
                    ctx.shadowBlur = lit ? 4 : 0;
                    ctx.fillRect(bx, by, bsz, bsz);
                    ctx.shadowBlur = 0;
                }
            }

            // === HUD TEXT OVERLAY (orange) ===
            ctx.fillStyle = 'rgba(255,136,68,0.5)';
            ctx.font = `${s * 0.009}px 'Press Start 2P'`;
            ctx.textAlign = 'left';
            ctx.fillText('SCORE ' + String(score).padStart(6, '0'), W * 0.14, H * 0.04);
            ctx.textAlign = 'right';
            ctx.fillText('WAVE ' + wave + '/' + MAX_WAVES, W * 0.86, H * 0.04);
            ctx.textAlign = 'center';
            ctx.fillText('KILLS ' + killed + '/' + waveTarget, W * 0.5, H * 0.04);

            // Muzzle flash (orange for snowspeeder)
            if (gunFlash > 0) {
                const gAlpha = gunFlash * 2;
                const sfoilFlash = [
                    { x: W * 0.03, y: H * 0.03 },
                    { x: W * 0.97, y: H * 0.03 },
                    { x: W * 0.05, y: H * 0.67 },
                    { x: W * 0.95, y: H * 0.67 },
                ];
                sfoilFlash.forEach(sf => {
                    ctx.fillStyle = `rgba(255,136,68,${gAlpha * 0.4})`;
                    ctx.shadowColor = '#ff8844';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(sf.x, sf.y, s * 0.015, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });
            }
        }

        // ===== COUNTDOWN / VICTORY =====
        function drawCountdown() {
            const cx = W / 2, cy = H * 0.4;
            ctx.shadowColor = 'rgba(255,136,68,0.4)'; ctx.shadowBlur = 10;
            ctx.fillStyle = '#ff8844';
            ctx.font = `${Math.min(W, H) * 0.018}px 'Press Start 2P'`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('WAVE ' + wave, cx, cy - Math.min(W, H) * 0.08);

            const text = CD_TEXT[countdownPhase];
            if (text) {
                const isNum = ['3', '2', '1'].includes(text);
                const isGo = text === 'ENGAGE!';
                const fontSize = isNum ? 0.08 : (isGo ? 0.05 : 0.016);
                const phase = countdownTimer / CD_DUR[countdownPhase];
                const scale = isNum ? 1 + Math.sin(phase * Math.PI) * 0.15 : 1;
                const alpha = isGo ? Math.max(0, 1 - phase * 2) : 1;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(scale, scale);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = isGo ? '#ff4040' : (text === 'ALL SPEEDERS REPORT IN' ? '#ff8844' : '#ff6040');
                ctx.font = `${Math.min(W, H) * fontSize}px 'Press Start 2P'`;
                ctx.fillText(text, 0, 0);
                ctx.restore();
                ctx.globalAlpha = 1;
            }
            ctx.shadowBlur = 0;
        }

        function drawVictory(dt) {
            victoryTimer += dt;
            const cx = W / 2, cy = H * 0.35;
            const t = victoryTimer;
            const s = Math.min(W, H);

            if (t > 1.5) {
                const ta = Math.min(1, (t - 1.5) / 1);
                ctx.globalAlpha = ta;
                ctx.shadowColor = 'rgba(255,200,50,0.5)'; ctx.shadowBlur = 15;

                const pulse = 1 + Math.sin(t * 4) * 0.04;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(pulse, pulse);
                ctx.fillStyle = '#88ccff';
                ctx.font = `${s * 0.035}px 'Press Start 2P'`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('THE BASE IS SAVED', 0, 0);
                ctx.restore();

                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff8844';
                ctx.font = `${s * 0.016}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText('ECHO BASE HOLDS', cx, cy + s * 0.07);

                ctx.fillStyle = '#ff8844';
                ctx.font = `${s * 0.014}px 'Press Start 2P'`;
                ctx.fillText('SCORE: ' + String(score).padStart(6, '0'), cx, cy + s * 0.13);

                ctx.fillStyle = '#88ccff';
                ctx.font = `${s * 0.012}px 'Press Start 2P'`;
                ctx.fillText('THE FORCE IS STRONG WITH YOU', cx, cy + s * 0.18);

                if (t > 3.5 && Math.floor(t * 2) % 2 === 0) {
                    ctx.fillStyle = '#ff8844';
                    ctx.font = `${s * 0.01}px 'Press Start 2P'`;
                    ctx.fillText('CLICK OR PRESS ENTER TO PLAY AGAIN', cx, cy + s * 0.25);
                }
                ctx.globalAlpha = 1;
            }
        }

        // ===== LOGIC =====
        function getWaveConfig(w) {
            return {
                target: 5 + w * 2,
                spawnInt: Math.max(1000 - w * 80, 400),
                maxOn: Math.min(4 + w, 12),
                bruteChance: Math.min(0.1 + w * 0.05, 0.4), // Wampa chance
            };
        }

        function spawnEnemy() {
            const cfg = getWaveConfig(wave);
            const isWampa = Math.random() < cfg.bruteChance;

            let x, y, z, vx, vy, vz;
            let flyby = false;

            if (isWampa) {
                // Wampas appear at ground level, running toward you
                const side = Math.random();
                if (side < 0.33) {
                    // From left ground
                    x = -0.3 + Math.random() * 0.2;
                    vx = 0.08 + Math.random() * 0.1;
                } else if (side < 0.66) {
                    // From right ground
                    x = 1.1 + Math.random() * 0.2;
                    vx = -(0.08 + Math.random() * 0.1);
                } else {
                    // From center-ish
                    x = 0.2 + Math.random() * 0.6;
                    vx = (Math.random() - 0.5) * 0.06;
                }
                y = 0.55 + Math.random() * 0.15; // Ground level
                z = 1.5 + Math.random() * 1.5;
                vy = (Math.random() - 0.5) * 0.02; // Minimal vertical movement
                vz = -(0.2 + Math.random() * 0.15 + wave * 0.02); // Approach speed
            } else {
                // Probe Droids - same spawn patterns as TIE fighters
                const spawnType = Math.random();

                if (spawnType < 0.15) {
                    x = -0.5; y = 0.2 + Math.random() * 0.5;
                    z = 1.2 + Math.random() * 1.0;
                    vx = 0.4 + Math.random() * 0.3;
                    vy = (Math.random() - 0.5) * 0.1;
                    vz = -(0.05 + Math.random() * 0.1);
                    flyby = true;
                } else if (spawnType < 0.30) {
                    x = 1.5; y = 0.2 + Math.random() * 0.5;
                    z = 1.2 + Math.random() * 1.0;
                    vx = -(0.4 + Math.random() * 0.3);
                    vy = (Math.random() - 0.5) * 0.1;
                    vz = -(0.05 + Math.random() * 0.1);
                    flyby = true;
                } else if (spawnType < 0.45) {
                    x = -0.3; y = 0.2 + Math.random() * 0.5;
                    z = 2 + Math.random() * 2;
                    vx = 0.15 + Math.random() * 0.2;
                    vy = (Math.random() - 0.5) * 0.15;
                } else if (spawnType < 0.60) {
                    x = 1.3; y = 0.2 + Math.random() * 0.5;
                    z = 2 + Math.random() * 2;
                    vx = -(0.15 + Math.random() * 0.2);
                    vy = (Math.random() - 0.5) * 0.15;
                } else if (spawnType < 0.75) {
                    x = 0.2 + Math.random() * 0.6; y = -0.2;
                    z = 2.5 + Math.random() * 2;
                    vx = (Math.random() - 0.5) * 0.15;
                    vy = 0.12 + Math.random() * 0.15;
                } else if (spawnType < 0.85) {
                    x = 0.2 + Math.random() * 0.6; y = 1.1;
                    z = 2 + Math.random() * 1.5;
                    vx = (Math.random() - 0.5) * 0.15;
                    vy = -(0.12 + Math.random() * 0.15);
                } else {
                    x = 0.25 + Math.random() * 0.5;
                    y = 0.2 + Math.random() * 0.4;
                    z = 5 + Math.random() * 2;
                    vx = (Math.random() - 0.5) * 0.2;
                    vy = (Math.random() - 0.5) * 0.1;
                }

                if (!flyby) {
                    vz = -(0.35 + Math.random() * 0.25 + wave * 0.04);
                }
            }

            enemies.push({
                x, y, z, vx, vy, vz,
                alive: true, t: 0, flyby,
                isWampa: isWampa,
                life: flyby ? 6000 + Math.random() * 3000 : (isWampa ? 12000 + Math.random() * 5000 : 10000 + Math.random() * 5000),
                shootCD: flyby ? 800 + Math.random() * 800 : (isWampa ? 2000 + Math.random() * 1500 : 2500 + Math.random() * 2000),
                flash: 0,
                hp: isWampa ? 3 : 1,
                screenX: 0, screenY: 0, screenSize: 0,
                wobblePhase: Math.random() * Math.PI * 2,
                wobbleSpd: flyby ? 0.5 : (isWampa ? 0.5 : 1.0 + Math.random() * 2.0),
            });
        }

        function shoot() {
            if (state !== 'playing') return;
            sfx.play('laser');
            gunFlash = 0.2;

            const gunScreenPos = [
                { sx: 0.03, sy: 0.03 },
                { sx: 0.97, sy: 0.03 },
                { sx: 0.05, sy: 0.67 },
                { sx: 0.95, sy: 0.67 },
            ];

            const startZ = 0.3;
            const targetZ = 3.5;

            const targetX = (crossX - 0.5) * targetZ + 0.5;
            const targetY = (crossY - 0.5) * targetZ + 0.5;

            gunScreenPos.forEach(gun => {
                const gunWorldX = gun.sx + camX;
                const gunWorldY = gun.sy + camY;
                const gx = (gunWorldX - 0.5) * startZ + 0.5;
                const gy = (gunWorldY - 0.5) * startZ + 0.5;

                const dx = targetX - gx;
                const dy = targetY - gy;
                const dz = targetZ - startZ;
                const d = Math.sqrt(dx * dx + dy * dy + dz * dz);
                const speed = 5.0;

                playerLasers.push({
                    x: gx, y: gy, z: startZ,
                    vx: (dx / d) * speed,
                    vy: (dy / d) * speed,
                    vz: (dz / d) * speed,
                });
            });
        }

        function takeDamage(amount) {
            shields -= amount;
            sfx.play('hit');
            shakeTimer = 0.3;
            cockpitDmgFlash = 1;
            if (shields <= 25) sfx.play('shield_alarm');
            if (shields <= 0) {
                shields = 0;
                state = 'gameover'; sfx.play('gameover');
                document.getElementById('finalScore').textContent = 'SCORE: ' + String(score).padStart(6, '0');
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }
        }

        function startCountdown() {
            state = 'countdown'; countdownPhase = 0; countdownTimer = 0;
            enemies = []; explosions = []; playerLasers = []; enemyLasers = [];
            particles = []; debris = [];
            const cfg = getWaveConfig(wave);
            waveTarget = cfg.target; spawnInterval = cfg.spawnInt; maxOnScreen = cfg.maxOn;
            killed = 0; spawnTimer = 0;
        }

        function nextWave() {
            if (wave >= MAX_WAVES) {
                state = 'victory'; victoryTimer = 0; sfx.play('victory');
                document.getElementById('winOverlay').style.display = 'flex';
                return;
            }
            wave++; startCountdown();
        }

        function updateCountdown(dt) {
            countdownTimer += dt * 1000;
            if (countdownTimer >= CD_DUR[countdownPhase]) {
                countdownTimer = 0; countdownPhase++;
                if (countdownPhase >= 2 && countdownPhase <= 4) sfx.play('countdown');
                if (countdownPhase === 5) sfx.play('go');
                if (countdownPhase >= CD_DUR.length) { state = 'playing'; return; }
            }
        }

        function update(dt) {
            cockpitDmgFlash = Math.max(0, cockpitDmgFlash - dt * 3);
            gunFlash = Math.max(0, gunFlash - dt * 3);
            if (shakeTimer > 0) {
                shakeTimer -= dt;
                shakeX = (Math.random() - 0.5) * 8;
                shakeY = (Math.random() - 0.5) * 8;
            } else { shakeX = 0; shakeY = 0; }

            if (state === 'countdown') { updateCountdown(dt); return; }
            if (state !== 'playing') return;

            // Crosshair movement
            const cs = 0.8;
            if (keys['ArrowLeft'] || keys['a']) crossX -= cs * dt;
            if (keys['ArrowRight'] || keys['d']) crossX += cs * dt;
            if (keys['ArrowUp'] || keys['w']) crossY -= cs * dt;
            if (keys['ArrowDown'] || keys['s']) crossY += cs * dt;
            crossX = Math.max(0.05, Math.min(0.95, crossX));
            crossY = Math.max(0.05, Math.min(0.95, crossY));

            // Camera pans
            const targetCamX = (crossX - 0.5) * 0.6;
            const targetCamY = (crossY - 0.5) * 0.6;
            const camSmooth = Math.min(1, dt * 5);
            camX += (targetCamX - camX) * camSmooth;
            camY += (targetCamY - camY) * camSmooth;

            // Spawn
            spawnTimer += dt * 1000;
            if (spawnTimer >= spawnInterval && enemies.filter(e => e.alive).length < maxOnScreen) {
                spawnEnemy(); spawnTimer = 0;
            }

            // Update enemies
            enemies.forEach(e => {
                if (!e.alive) return;
                e.t += dt * 1000;

                const wobAmt = e.flyby ? 0.02 : (e.isWampa ? 0.03 : 0.08);
                e.x += e.vx * dt + Math.sin(e.t * 0.002 * e.wobbleSpd + e.wobblePhase) * wobAmt * dt;
                e.y += e.vy * dt + Math.cos(e.t * 0.0025 * e.wobbleSpd) * wobAmt * 0.75 * dt;
                e.z += e.vz * dt;

                // Keep wampas at ground level
                if (e.isWampa) {
                    e.y = Math.max(0.55, Math.min(0.7, e.y));
                }

                if (e.flyby) {
                    if (e.x < -0.8 || e.x > 1.8 || e.y < -0.5 || e.y > 1.5) { e.alive = false; return; }
                } else {
                    e.x = Math.max(-0.5, Math.min(1.5, e.x));
                    if (!e.isWampa) e.y = Math.max(-0.3, Math.min(1.2, e.y));
                }

                if (e.z < 0.3) { e.alive = false; return; }

                // Shoot at player
                e.shootCD -= dt * 1000;
                if (e.shootCD <= 0 && e.z < 3.0) {
                    e.flash = 150;
                    e.shootCD = Math.max(1500, 3000 - wave * 120) + Math.random() * 1500;
                    sfx.play('tie_laser');

                    const dx = 0.5 - e.x + (Math.random() - 0.5) * 0.15;
                    const dy = 0.7 - e.y;
                    const dz = -e.z;
                    const d = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    const bspd = 2.5 + wave * 0.1;
                    enemyLasers.push({
                        x: e.x, y: e.y, z: e.z,
                        vx: (dx / d) * bspd, vy: (dy / d) * bspd, vz: (dz / d) * bspd,
                        isIce: e.isWampa,
                    });
                }
                if (e.flash > 0) e.flash -= dt * 1000;
                if (e.t > e.life) e.alive = false;
            });
            enemies = enemies.filter(e => e.alive);

            // Player lasers
            playerLasers = playerLasers.filter(b => {
                b.x += b.vx * dt; b.y += b.vy * dt; b.z += b.vz * dt;
                for (let e of enemies) {
                    if (!e.alive) continue;
                    const dx = b.x - e.x, dy = b.y - e.y, dz = b.z - e.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    const hitRadius = e.isWampa ? 0.25 : 0.2;
                    if (dist < hitRadius) {
                        if (e.hp > 1) {
                            e.hp--; e.flash = 200;
                            sfx.play('hit');
                        } else {
                            e.alive = false;
                            // Wampas worth more, probe droid flybys worth more than normal
                            if (e.isWampa) {
                                score += 1000 * wave;
                            } else {
                                score += (e.flyby ? 800 : 500) * wave;
                            }
                            killed++;
                            sfx.play('tie_explode');
                            explosions.push({ x: e.x, y: e.y, z: e.z, progress: 0, spin: Math.random() * Math.PI * 2 });
                            for (let i = 0; i < 6; i++) {
                                debris.push({
                                    x: e.x, y: e.y, z: e.z,
                                    vx: (Math.random() - 0.5) * 0.8,
                                    vy: (Math.random() - 0.5) * 0.8,
                                    vz: (Math.random() - 0.5) * 0.5,
                                    rot: Math.random() * Math.PI * 2,
                                    rotV: (Math.random() - 0.5) * 5,
                                    size: 3 + Math.random() * 5,
                                    alpha: 1, life: 1.5 + Math.random(),
                                });
                            }
                        }
                        return false;
                    }
                }
                return b.z > 0 && b.z < 6;
            });

            // Enemy lasers
            enemyLasers = enemyLasers.filter(b => {
                b.x += b.vx * dt; b.y += b.vy * dt; b.z += b.vz * dt;
                if (b.z < 0.2 && Math.abs(b.x - 0.5) < 0.2 && Math.abs(b.y - 0.5) < 0.3) {
                    takeDamage(8 + wave);
                    return false;
                }
                return b.z > -0.5 && b.z < 5;
            });

            explosions.forEach(ex => { ex.progress += dt * 2.0; ex.spin += dt * 3; });
            explosions = explosions.filter(ex => ex.progress < 1);

            debris.forEach(d => {
                d.x += d.vx * dt; d.y += d.vy * dt; d.z += d.vz * dt;
                d.rot += d.rotV * dt;
                d.alpha -= dt * 0.5; d.life -= dt;
            });
            debris = debris.filter(d => d.life > 0 && d.alpha > 0);

            if (killed >= waveTarget) nextWave();
        }

        function draw(dt) {
            ctx.clearRect(0, 0, W, H);

            // Fill cockpit area black first so nothing shows through
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, H * 0.62, W, H * 0.38);

            // Camera pan offset
            const camPxX = -camX * W;
            const camPxY = -camY * H;

            // Clip viewport to canopy opening so background doesn't bleed into cockpit
            ctx.save();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(W, 0);
            ctx.lineTo(W, H * 0.68);
            ctx.lineTo(W * 0.72, H * 0.64);
            ctx.lineTo(W * 0.62, H * 0.64);
            ctx.lineTo(W * 0.50, H * 0.60);
            ctx.lineTo(W * 0.38, H * 0.64);
            ctx.lineTo(W * 0.28, H * 0.64);
            ctx.lineTo(0, H * 0.68);
            ctx.closePath();
            ctx.clip();

            ctx.save();
            ctx.translate(shakeX + camPxX, shakeY + camPxY);

            drawHothBackground(dt);

            if (state === 'victory') {
                ctx.restore(); // undo translate
                ctx.restore(); // undo clip
                drawCockpit();
                ctx.save();
                ctx.translate(shakeX + camPxX, shakeY + camPxY);
                drawVictory(dt);
                ctx.restore();
                return;
            }

            // Sort everything by depth
            const allObjects = [];

            enemies.forEach(e => { if (e.alive) allObjects.push({ type: 'enemy', obj: e, z: e.z }); });
            playerLasers.forEach(b => allObjects.push({ type: 'plaser', obj: b, z: b.z }));
            enemyLasers.forEach(b => allObjects.push({ type: 'elaser', obj: b, z: b.z }));
            explosions.forEach(ex => allObjects.push({ type: 'explosion', obj: ex, z: ex.z }));
            debris.forEach(d => allObjects.push({ type: 'debris', obj: d, z: d.z }));

            allObjects.sort((a, b) => b.z - a.z);

            allObjects.forEach(o => {
                if (o.type === 'enemy') {
                    if (o.obj.isWampa) drawWampa(o.obj);
                    else drawProbeDroid(o.obj);
                }
                else if (o.type === 'plaser') drawPlayerLaser(o.obj);
                else if (o.type === 'elaser') drawEnemyLaser(o.obj);
                else if (o.type === 'explosion') drawExplosion(o.obj);
                else if (o.type === 'debris') drawDebris(o.obj);
            });

            ctx.restore(); // undo translate
            ctx.restore(); // undo viewport clip

            // Cockpit always on top
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawCockpit();

            if (state === 'countdown') {
                drawCountdown();
            }

            ctx.restore();
            if (state === 'playing') {
                ctx.save();
                ctx.translate(shakeX + camPxX, shakeY + camPxY);
                drawCrosshair();
                ctx.restore();
            }
        }

        function loop(ts) {
            const dt = Math.min((ts - lastTime) / 1000, 0.05);
            lastTime = ts;
            resize(); update(dt); draw(dt);
            requestAnimationFrame(loop);
        }

        function startGame() {
            score = 0; shields = 100; wave = 1;
            enemies = []; explosions = []; playerLasers = []; enemyLasers = [];
            particles = []; debris = [];
            crossX = 0.5; crossY = 0.4; camX = 0; camY = 0; shakeTimer = 0; cockpitDmgFlash = 0; gunFlash = 0;
            initSnow();
            initMountains();
            document.getElementById('startOverlay').style.display = 'none';
            document.getElementById('gameOverOverlay').style.display = 'none';
            document.getElementById('winOverlay').style.display = 'none';
            sfx.init(); startCountdown();
        }

        // ===== INPUT =====
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                if (state === 'start' || state === 'gameover' || state === 'victory') startGame();
                else if (state === 'playing' && e.key === ' ') shoot();
            }
        });
        document.addEventListener('keyup', e => { keys[e.key] = false; });

        function screenToGame(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: Math.max(0.05, Math.min(0.95, (clientX - rect.left) / rect.width)),
                y: Math.max(0.05, Math.min(0.95, (clientY - rect.top) / rect.height)),
            };
        }

        canvas.addEventListener('mousemove', e => {
            if (state !== 'playing') return;
            const pos = screenToGame(e.clientX, e.clientY);
            crossX = pos.x; crossY = pos.y;
        });

        canvas.addEventListener('click', e => {
            e.preventDefault(); sfx.init();
            if (state === 'start' || state === 'gameover' || state === 'victory') startGame();
            else if (state === 'playing') {
                const pos = screenToGame(e.clientX, e.clientY);
                crossX = pos.x; crossY = pos.y;
                shoot();
            }
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); sfx.init();
            if (state === 'start' || state === 'gameover' || state === 'victory') { startGame(); return; }
            if (state === 'playing') {
                const pos = screenToGame(e.touches[0].clientX, e.touches[0].clientY);
                crossX = pos.x; crossY = pos.y;
                shoot();
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (state !== 'playing') return;
            const pos = screenToGame(e.touches[0].clientX, e.touches[0].clientY);
            crossX = pos.x; crossY = pos.y;
        }, { passive: false });

        ['startOverlay', 'gameOverOverlay', 'winOverlay'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('click', e => { e.preventDefault(); e.stopPropagation(); sfx.init(); startGame(); });
            el.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); sfx.init(); startGame(); }, { passive: false });
        });

        requestAnimationFrame(loop);
    </script>
</body>

</html>
