<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ENDOR CHASE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Press Start 2P', monospace;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: none;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 80;
            pointer-events: auto;
            cursor: pointer;
            background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.95));
        }

        .overlay-text {
            color: #44ff44;
            text-align: center;
            text-shadow: 0 0 15px rgba(68, 255, 68, 0.5);
        }

        .overlay-text .big {
            font-size: 16px;
            display: block;
            margin-bottom: 16px;
            letter-spacing: 3px;
        }

        .overlay-text .med {
            font-size: 9px;
            display: block;
            margin-bottom: 10px;
            color: #ffaa00;
        }

        .overlay-text .small {
            font-size: 8px;
            display: block;
            opacity: 0.8;
            color: #ffaa00;
            animation: blink 1s infinite;
        }

        @keyframes blink {

            0%,
            49% {
                opacity: 0.8
            }

            50%,
            100% {
                opacity: 0.2
            }
        }

        @media (min-width:600px) {
            .overlay-text .big {
                font-size: 26px;
            }
        }
        #exitBtn{position:fixed;top:10px;right:10px;z-index:100;font-family:'Press Start 2P',monospace;font-size:9px;color:#999;text-decoration:none;background:rgba(0,0,0,0.7);padding:6px 12px;border:1px solid #555;border-radius:2px;cursor:pointer;transition:all 0.15s}
        #exitBtn:hover{border-color:#44ff44;color:#44ff44;background:rgba(0,20,0,0.8)}
    </style>
</head>

<body>
    <canvas id="c"></canvas>

    <div class="overlay" id="startOverlay">
        <div class="overlay-text">
            <span class="big">&#127795; ENDOR CHASE &#127795;</span>
            <span class="med">THE SHIELD GENERATOR MUST BE DESTROYED</span>
            <span class="med" style="color:#ffaa00">MOUNT YOUR SPEEDER BIKE &mdash; CLEAR THE FOREST</span>
            <span class="small">&#9658; CLICK OR PRESS ENTER &#9668;</span>
            <br><a href="Index.html" style="font-family:'Press Start 2P',monospace;font-size:8px;color:#ff0;text-decoration:none;background:rgba(0,0,0,0.6);padding:6px 10px;border:1px solid #ff0;border-radius:3px">&#9664; ARCADE</a>
        </div>
    </div>

    <div class="overlay" id="gameOverOverlay" style="display:none;">
        <div class="overlay-text">
            <span class="big" style="color:#ff4040">SPEEDER DESTROYED</span>
            <span class="med" id="finalScore"></span>
            <span class="small">&#9658; CLICK OR PRESS ENTER &#9668;</span>
            <br><a href="Index.html" style="font-family:'Press Start 2P',monospace;font-size:8px;color:#ff0;text-decoration:none;background:rgba(0,0,0,0.6);padding:6px 10px;border:1px solid #ff0;border-radius:3px">&#9664; ARCADE</a>
        </div>
    </div>

    <div class="overlay" id="winOverlay" style="display:none;background:transparent;"><div style="position:absolute;bottom:15%;left:50%;transform:translateX(-50%)"><a href="Index.html" style="font-family:'Press Start 2P',monospace;font-size:8px;color:#ff0;text-decoration:none;background:rgba(0,0,0,0.6);padding:6px 10px;border:1px solid #ff0;border-radius:3px">&#9664; ARCADE</a></div></div>

    <a id="exitBtn" href="Index.html">&#10005; EXIT</a>

    <script>
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');

        // ===== AUDIO =====
        class SFX {
            constructor() { this.ctx = null; }
            init() {
                if (this.ctx) return;
                try { this.ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) { }
            }
            play(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = () => this.ctx.createOscillator();
                const gn = () => this.ctx.createGain();

                if (type === 'laser') {
                    // Green rebel blaster — higher pitched, quick chirp
                    [0, 0.025, 0.05].forEach((d, i) => {
                        const o = osc(), g = gn();
                        o.type = 'square'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(1200 - i * 100, t + d);
                        o.frequency.exponentialRampToValueAtTime(300, t + d + 0.06);
                        g.gain.setValueAtTime(0.05, t + d);
                        g.gain.exponentialRampToValueAtTime(0.001, t + d + 0.06);
                        o.start(t + d); o.stop(t + d + 0.07);
                    });
                }
                if (type === 'enemy_laser') {
                    const o = osc(), g = gn();
                    o.type = 'sawtooth'; o.connect(g); g.connect(this.ctx.destination);
                    o.frequency.setValueAtTime(700, t);
                    o.frequency.exponentialRampToValueAtTime(180, t + 0.1);
                    g.gain.setValueAtTime(0.04, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
                    o.start(t); o.stop(t + 0.1);
                }
                if (type === 'explode') {
                    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.5, this.ctx.sampleRate);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 0.5);
                    const src = this.ctx.createBufferSource(), g = gn();
                    src.buffer = buf; src.connect(g); g.connect(this.ctx.destination);
                    g.gain.setValueAtTime(0.2, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                    src.start(t);
                    const o = osc(), g2 = gn();
                    o.type = 'sine'; o.connect(g2); g2.connect(this.ctx.destination);
                    o.frequency.setValueAtTime(150, t);
                    o.frequency.exponentialRampToValueAtTime(25, t + 0.45);
                    g2.gain.setValueAtTime(0.14, t);
                    g2.gain.exponentialRampToValueAtTime(0.001, t + 0.45);
                    o.start(t); o.stop(t + 0.45);
                }
                if (type === 'hit') {
                    const buf = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                    const d = buf.getChannelData(0);
                    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / d.length, 1.5);
                    const src = this.ctx.createBufferSource(), g = gn();
                    src.buffer = buf; src.connect(g); g.connect(this.ctx.destination);
                    g.gain.setValueAtTime(0.15, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                    src.start(t);
                }
                if (type === 'shield_alarm') {
                    [400, 300, 400, 300].forEach((f, i) => {
                        const o = osc(), g = gn();
                        o.type = 'square'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(f, t + i * 0.12);
                        g.gain.setValueAtTime(0.03, t + i * 0.12);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.12 + 0.11);
                        o.start(t + i * 0.12); o.stop(t + i * 0.12 + 0.12);
                    });
                }
                if (type === 'countdown') {
                    const o = osc(), g = gn();
                    o.type = 'sine'; o.connect(g); g.connect(this.ctx.destination);
                    o.frequency.setValueAtTime(600, t);
                    g.gain.setValueAtTime(0.04, t);
                    g.gain.exponentialRampToValueAtTime(0.001, t + 0.07);
                    o.start(t); o.stop(t + 0.07);
                }
                if (type === 'go') {
                    [800, 1000, 1200].forEach((f, i) => {
                        const o = osc(), g = gn();
                        o.type = 'sine'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(f, t + i * 0.06);
                        g.gain.setValueAtTime(0.04, t + i * 0.06);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.06 + 0.07);
                        o.start(t + i * 0.06); o.stop(t + i * 0.06 + 0.07);
                    });
                }
                if (type === 'gameover') {
                    [300, 250, 200, 150, 100].forEach((f, i) => {
                        const o = osc(), g = gn();
                        o.type = 'triangle'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(f, t + i * 0.3);
                        g.gain.setValueAtTime(0.06, t + i * 0.3);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.3 + 0.29);
                        o.start(t + i * 0.3); o.stop(t + i * 0.3 + 0.3);
                    });
                }
                if (type === 'victory') {
                    [392, 523, 659, 784, 659, 784, 1047].forEach((f, i) => {
                        const o = osc(), g = gn();
                        o.type = i < 4 ? 'sine' : 'triangle'; o.connect(g); g.connect(this.ctx.destination);
                        o.frequency.setValueAtTime(f, t + i * 0.2);
                        g.gain.setValueAtTime(0.06, t + i * 0.2);
                        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.2 + 0.19);
                        o.start(t + i * 0.2); o.stop(t + i * 0.2 + 0.2);
                    });
                }
            }
        }

        const sfx = new SFX();
        const MAX_WAVES = 9;
        let W, H;
        let state = 'start';
        let score = 0, shields = 100, wave = 1;
        let enemies = [], explosions = [], playerLasers = [], enemyLasers = [], debris = [];
        let crossX = 0.5, crossY = 0.5;
        let camX = 0, camY = 0;
        let keys = {};
        let spawnTimer = 0, spawnInterval = 1800;
        let killed = 0, waveTarget = 6;
        let maxOnScreen = 4;
        let lastTime = 0;
        let shakeX = 0, shakeY = 0, shakeTimer = 0;
        let gunFlash = 0;
        let dmgFlash = 0;

        // Countdown
        let countdownPhase = 0, countdownTimer = 0;
        const CD_DUR = [800, 700, 700, 700, 700, 400];
        const CD_TEXT = ['', 'ALL SPEEDERS LAUNCH', '3', '2', '1', 'PUNCH IT!'];
        let victoryTimer = 0;

        // ===== AUTO-SWERVE =====
        let swerveAmount = 0;
        let swerveTarget = 0;
        let swerveTimer = 0;
        let swerveInterval = 2.0;
        let totalTime = 0;

        // ===== 3D FOREST (trees rush toward player) =====
        const VP_Y = 0.12; // Vanishing point Y (horizon — very low, ground-level speeder)
        const TREE_COUNT = 45;
        const TREE_FAR = 14;
        const TREE_NEAR = 0.3;
        const TREE_SPEED = 3.5; // Base forward speed
        let trees3d = [];

        function spawnTree(farOnly) {
            const zMin = farOnly ? 6 : 2;
            const z = zMin + Math.random() * (TREE_FAR - zMin);
            // Wide horizontal spread — trees scattered across the forest floor
            const x = (Math.random() - 0.5) * 7.0;
            // Keep a clear center path so you fly between trunks
            const absX = Math.abs(x);
            const finalX = absX < 0.5 ? (x < 0 ? x - 0.6 : x + 0.6) : x;
            return {
                x: finalX,
                z: z,
                baseWidth: 0.08 + Math.random() * 0.12,
                shade: Math.random(),
                barkLines: Math.floor(2 + Math.random() * 4),
                hasFoliage: Math.random() > 0.2,
                foliageSize: 0.6 + Math.random() * 0.8,
            };
        }

        // Ground debris: brush clumps, downed logs, ferns
        const DEBRIS_COUNT = 30;
        let groundDebris = [];

        function spawnGroundDebris(farOnly) {
            const zMin = farOnly ? 5 : 1.5;
            const z = zMin + Math.random() * (TREE_FAR - zMin);
            const x = (Math.random() - 0.5) * 6.0;
            const types = ['brush', 'log', 'fern', 'rocks', 'stump'];
            return {
                x: x,
                z: z,
                type: types[Math.floor(Math.random() * types.length)],
                size: 0.3 + Math.random() * 0.7,
                shade: Math.random(),
                angle: (Math.random() - 0.5) * 0.4,
            };
        }

        function initForest() {
            trees3d = [];
            for (let i = 0; i < TREE_COUNT; i++) {
                trees3d.push(spawnTree(false));
            }
            trees3d.sort((a, b) => b.z - a.z);
            groundDebris = [];
            for (let i = 0; i < DEBRIS_COUNT; i++) {
                groundDebris.push(spawnGroundDebris(false));
            }
        }

        function resize() {
            W = canvas.width = window.innerWidth * 2;
            H = canvas.height = window.innerHeight * 2;
        }
        window.addEventListener('resize', resize);
        resize();
        initForest();

        // ===== DRAWING =====

        function drawEndorForest(dt) {
            const speed = state === 'playing' ? 1.0 : 0.3;
            totalTime += dt * speed;
            const vpX = W * 0.5;
            const vpY = H * VP_Y;

            // ===== MOVE TREES FORWARD =====
            const fwdSpeed = TREE_SPEED * speed;
            trees3d.forEach(tr => {
                tr.z -= fwdSpeed * dt;
                // Swerve shifts trees laterally (near trees shift more)
                tr.x += swerveAmount * dt * (1.5 / Math.max(tr.z, 0.5));
                if (tr.z < TREE_NEAR) {
                    // Respawn far away
                    const nt = spawnTree(true);
                    tr.x = nt.x; tr.z = nt.z;
                    tr.baseWidth = nt.baseWidth; tr.shade = nt.shade;
                    tr.barkLines = nt.barkLines; tr.hasFoliage = nt.hasFoliage;
                    tr.foliageSize = nt.foliageSize;
                }
            });
            // Sort back-to-front for painter's algorithm
            trees3d.sort((a, b) => b.z - a.z);

            // ===== SKY (thin strip — mostly forest and ground visible) =====
            const skyGrad = ctx.createLinearGradient(0, 0, 0, vpY);
            skyGrad.addColorStop(0, '#3a6aaa');
            skyGrad.addColorStop(0.6, '#5a8aba');
            skyGrad.addColorStop(1, '#4a7a4a');
            ctx.fillStyle = skyGrad;
            ctx.fillRect(0, 0, W, vpY + H * 0.03);

            // ===== CANOPY CEILING (tiny strip — barely visible from ground) =====
            const canopyBase = H * 0.08;
            ctx.fillStyle = '#1a3a0a';
            ctx.fillRect(0, 0, W, canopyBase);

            // Canopy leaf clusters
            for (let i = 0; i < 35; i++) {
                const cx = ((i * 137.5 + totalTime * 12) % (W + 300)) - 150;
                const cy = canopyBase * (0.25 + Math.sin(i * 2.7) * 0.22);
                const rx = 50 + Math.sin(i * 1.3) * 30;
                const ry = 25 + Math.cos(i * 0.9) * 15;
                const g = Math.floor(40 + Math.sin(i * 0.7) * 15);
                ctx.fillStyle = `rgb(${Math.floor(18 + Math.sin(i * 1.1) * 8)},${g + 18},${Math.floor(6 + Math.sin(i * 0.5) * 4)})`;
                ctx.beginPath();
                ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Canopy bottom fringe
            for (let i = 0; i < 60; i++) {
                const fx = ((i * 79.3 + totalTime * 8) % (W + 200)) - 100;
                const fy = canopyBase + Math.sin(i * 1.7) * H * 0.035;
                const r = 18 + Math.sin(i * 2.1) * 12;
                ctx.fillStyle = `rgb(${18 + (i % 10)},${42 + (i % 15)},${6 + (i % 6)})`;
                ctx.beginPath();
                ctx.ellipse(fx, fy, r * 1.8, r, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Golden light spots through canopy
            for (let i = 0; i < 10; i++) {
                const sx = ((i * 211 + totalTime * 6) % (W + 200)) - 100;
                const sy = canopyBase * (0.15 + Math.sin(i * 3.1) * 0.12);
                const sr = 10 + Math.sin(i * 1.5 + totalTime * 0.3) * 5;
                const alpha = 0.12 + Math.sin(totalTime * 0.5 + i * 2) * 0.06;
                ctx.fillStyle = `rgba(255,215,0,${alpha})`;
                ctx.beginPath();
                ctx.arc(sx, sy, sr, 0, Math.PI * 2);
                ctx.fill();
            }

            // ===== FAR FOREST WALL behind trees =====
            const forestGrad = ctx.createLinearGradient(0, canopyBase, 0, vpY + H * 0.15);
            forestGrad.addColorStop(0, '#1a3a0a');
            forestGrad.addColorStop(0.5, '#2a4a15');
            forestGrad.addColorStop(1, '#1a3008');
            ctx.fillStyle = forestGrad;
            ctx.fillRect(0, canopyBase, W, vpY + H * 0.15 - canopyBase);

            // ===== GROUND (big area — we're low, mostly ground visible) =====
            const groundGrad = ctx.createLinearGradient(0, vpY, 0, H);
            groundGrad.addColorStop(0, '#2a3a12');
            groundGrad.addColorStop(0.05, '#2a2010');
            groundGrad.addColorStop(0.15, '#3a2a10');
            groundGrad.addColorStop(0.35, '#302008');
            groundGrad.addColorStop(0.6, '#2a1a08');
            groundGrad.addColorStop(1, '#1a1005');
            ctx.fillStyle = groundGrad;
            ctx.fillRect(0, vpY, W, H - vpY);

            // Undergrowth patches (mossy green/brown splotches on ground)
            for (let i = 0; i < 18; i++) {
                const patchFrac = (i + 1) / 19;
                const py = vpY + (H - vpY) * (patchFrac * patchFrac);
                const px = ((i * 197 + totalTime * 30 * patchFrac) % (W + 200)) - 100;
                const pr = 15 + patchFrac * 40;
                const gv = Math.floor(30 + Math.sin(i * 1.3) * 10);
                ctx.fillStyle = `rgba(${gv - 10},${gv + 10},${gv - 18},${0.15 + patchFrac * 0.1})`;
                ctx.beginPath();
                ctx.ellipse(px, py, pr * 1.5, pr * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
            }

            // Perspective ground lines radiating from vanishing point
            if (state === 'playing' || state === 'countdown') {
                ctx.strokeStyle = 'rgba(60,45,20,0.25)';
                ctx.lineWidth = 1.5;
                for (let i = -8; i <= 8; i++) {
                    const angle = i * 0.12;
                    ctx.beginPath();
                    ctx.moveTo(vpX, vpY);
                    ctx.lineTo(vpX + Math.tan(angle) * H * 1.5, H);
                    ctx.stroke();
                }
                // Horizontal depth lines (closer = more spread)
                for (let i = 1; i <= 10; i++) {
                    const frac = i / 10;
                    const ly = vpY + (H - vpY) * (frac * frac); // quadratic = perspective
                    ctx.strokeStyle = `rgba(60,45,20,${0.1 + frac * 0.15})`;
                    ctx.lineWidth = 1 + frac;
                    ctx.beginPath();
                    ctx.moveTo(0, ly);
                    ctx.lineTo(W, ly);
                    ctx.stroke();
                }
            }

            // Speed blur lines on ground (rushing toward you)
            if (state === 'playing') {
                for (let i = 0; i < 20; i++) {
                    const angle = ((i * 0.314 + totalTime * 1.5) % 3.14) - 1.57;
                    const near = 0.3 + (i % 5) * 0.12;
                    const far = near + 0.08;
                    const x1 = vpX + Math.sin(angle) * (H - vpY) * near * 1.8;
                    const y1 = vpY + (H - vpY) * near;
                    const x2 = vpX + Math.sin(angle) * (H - vpY) * far * 1.8;
                    const y2 = vpY + (H - vpY) * far;
                    ctx.strokeStyle = `rgba(80,60,30,${0.15 + near * 0.15})`;
                    ctx.lineWidth = 1 + near * 2;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                }
            }

            // ===== 3D TREES (sorted back-to-front) =====
            trees3d.forEach(tr => {
                if (tr.z < TREE_NEAR || tr.z > TREE_FAR) return;
                const scale = 1 / tr.z;

                // Project tree X: wide spread from vanishing point
                const screenX = vpX + tr.x * W * 0.5 * scale;
                const trunkW = tr.baseWidth * W * scale;

                // Tree base anchored on ground plane below horizon
                // Closer trees have baseY further below horizon (closer to bottom of screen)
                const groundPlane = vpY + (H - vpY) * Math.min(1, 1.2 / tr.z);
                // Trunks grow UP from ground — taller when closer
                const trunkH = H * 1.2 * scale;
                const baseY = groundPlane;
                // Top goes above horizon for close trees (you see just the trunk base)
                const topY = baseY - trunkH;

                // Skip if off screen
                if (screenX + trunkW < -50 || screenX - trunkW > W + 50) return;
                if (baseY < vpY) return;

                // Depth-based coloring: far = hazy green, near = dark brown
                const depthFrac = Math.min(1, (tr.z - TREE_NEAR) / (TREE_FAR - TREE_NEAR));
                const r = Math.floor(35 + (1 - depthFrac) * 30 + tr.shade * 15);
                const g = Math.floor(25 + depthFrac * 30 + tr.shade * 10);
                const b = Math.floor(10 + tr.shade * 8);

                // Trunk gradient (left-right lighting)
                if (trunkW > 3) {
                    const tGrad = ctx.createLinearGradient(screenX - trunkW / 2, 0, screenX + trunkW / 2, 0);
                    tGrad.addColorStop(0, `rgb(${r - 10},${g - 10},${b})`);
                    tGrad.addColorStop(0.35, `rgb(${r + 12},${g + 5},${b + 5})`);
                    tGrad.addColorStop(0.65, `rgb(${r + 8},${g + 2},${b + 3})`);
                    tGrad.addColorStop(1, `rgb(${r - 15},${g - 15},${b - 5})`);
                    ctx.fillStyle = tGrad;
                } else {
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                }

                // Draw trunk — extends from top down past base into ground
                ctx.fillRect(screenX - trunkW / 2, topY, trunkW, H - topY);

                // Bark texture lines (only on close enough trees)
                if (tr.z < 6 && trunkW > 6) {
                    ctx.strokeStyle = `rgba(${r + 25},${g + 10},${b + 5},${0.15 + (1 - depthFrac) * 0.15})`;
                    ctx.lineWidth = Math.max(1, trunkW * 0.04);
                    for (let bl = 0; bl < tr.barkLines; bl++) {
                        const by = topY + trunkH * (bl / tr.barkLines) + trunkH * 0.1;
                        ctx.beginPath();
                        ctx.moveTo(screenX - trunkW * 0.35, by);
                        ctx.quadraticCurveTo(screenX, by + trunkH * 0.03, screenX + trunkW * 0.35, by + trunkH * 0.015);
                        ctx.stroke();
                    }
                }

                // Foliage at top of trunk (only visible on distant trees)
                if (tr.hasFoliage && topY > -H * 0.2 && tr.z > 3) {
                    const fSize = trunkW * tr.foliageSize * 2.5;
                    const fg = Math.floor(35 + depthFrac * 25 + tr.shade * 10);
                    const fr = Math.floor(15 + tr.shade * 10);
                    ctx.fillStyle = `rgb(${fr},${fg + 10},${Math.floor(5 + tr.shade * 5)})`;
                    ctx.beginPath();
                    ctx.ellipse(screenX, topY, fSize, fSize * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Darker inner foliage
                    ctx.fillStyle = `rgb(${fr - 5},${fg},${Math.floor(3 + tr.shade * 3)})`;
                    ctx.beginPath();
                    ctx.ellipse(screenX - fSize * 0.15, topY + fSize * 0.1, fSize * 0.6, fSize * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // ===== GROUND DEBRIS (brush, logs, ferns rushing toward you) =====
            groundDebris.forEach(gd => {
                gd.z -= fwdSpeed * dt;
                gd.x += swerveAmount * dt * (1.2 / Math.max(gd.z, 0.5));
                if (gd.z < TREE_NEAR + 0.2) {
                    const nd = spawnGroundDebris(true);
                    gd.x = nd.x; gd.z = nd.z; gd.type = nd.type;
                    gd.size = nd.size; gd.shade = nd.shade; gd.angle = nd.angle;
                }
                if (gd.z > TREE_FAR || gd.z < TREE_NEAR) return;

                const scale = 1 / gd.z;
                const sx = vpX + gd.x * W * 0.5 * scale;
                const gPlane = vpY + (H - vpY) * Math.min(1, 1.2 / gd.z);
                const sz = W * 0.04 * gd.size * scale;

                if (sx < -100 || sx > W + 100 || gPlane < vpY) return;

                const depthFrac = Math.min(1, (gd.z - TREE_NEAR) / (TREE_FAR - TREE_NEAR));
                const alpha = 0.5 + (1 - depthFrac) * 0.5;

                ctx.save();
                ctx.translate(sx, gPlane);
                ctx.rotate(gd.angle);
                ctx.globalAlpha = alpha;

                if (gd.type === 'brush') {
                    // Green bush clump
                    const gr = Math.floor(40 + gd.shade * 20);
                    ctx.fillStyle = `rgb(${gr - 15},${gr + 15},${gr - 25})`;
                    ctx.beginPath();
                    ctx.ellipse(0, -sz * 0.3, sz * 1.2, sz * 0.5, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = `rgb(${gr - 20},${gr + 8},${gr - 30})`;
                    ctx.beginPath();
                    ctx.ellipse(-sz * 0.3, -sz * 0.2, sz * 0.6, sz * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(sz * 0.4, -sz * 0.15, sz * 0.5, sz * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (gd.type === 'log') {
                    // Downed tree trunk — horizontal brown cylinder
                    const br = Math.floor(50 + gd.shade * 20);
                    ctx.fillStyle = `rgb(${br + 10},${br - 10},${br - 25})`;
                    ctx.fillRect(-sz * 1.8, -sz * 0.2, sz * 3.6, sz * 0.4);
                    // Bark highlights
                    ctx.strokeStyle = `rgba(${br + 25},${br},${br - 15},0.3)`;
                    ctx.lineWidth = Math.max(1, sz * 0.05);
                    ctx.beginPath();
                    ctx.moveTo(-sz * 1.6, -sz * 0.05);
                    ctx.lineTo(sz * 1.6, -sz * 0.05);
                    ctx.stroke();
                    // Broken end
                    ctx.fillStyle = `rgb(${br - 5},${br - 20},${br - 35})`;
                    ctx.beginPath();
                    ctx.ellipse(sz * 1.8, 0, sz * 0.15, sz * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (gd.type === 'fern') {
                    // Fern fronds spreading out
                    const fg = Math.floor(45 + gd.shade * 15);
                    ctx.strokeStyle = `rgb(${fg - 15},${fg + 10},${fg - 25})`;
                    ctx.lineWidth = Math.max(1, sz * 0.06);
                    for (let f = 0; f < 5; f++) {
                        const fa = (f - 2) * 0.5;
                        const fl = sz * (0.8 + Math.sin(f * 1.5) * 0.3);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(Math.cos(fa) * fl * 0.5, -fl * 0.6, Math.cos(fa) * fl, -fl * 0.3);
                        ctx.stroke();
                        // Leaf blobs along frond
                        ctx.fillStyle = `rgb(${fg - 18},${fg + 5},${fg - 28})`;
                        ctx.beginPath();
                        ctx.ellipse(Math.cos(fa) * fl * 0.6, -fl * 0.4, sz * 0.15, sz * 0.08, fa, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else if (gd.type === 'rocks') {
                    // Small rock cluster
                    const rk = Math.floor(55 + gd.shade * 15);
                    ctx.fillStyle = `rgb(${rk},${rk - 5},${rk - 10})`;
                    ctx.beginPath();
                    ctx.ellipse(0, -sz * 0.1, sz * 0.4, sz * 0.25, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = `rgb(${rk - 8},${rk - 12},${rk - 18})`;
                    ctx.beginPath();
                    ctx.ellipse(sz * 0.3, -sz * 0.05, sz * 0.25, sz * 0.18, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.ellipse(-sz * 0.25, 0, sz * 0.2, sz * 0.15, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (gd.type === 'stump') {
                    // Cut tree stump
                    const st = Math.floor(45 + gd.shade * 18);
                    ctx.fillStyle = `rgb(${st + 10},${st - 5},${st - 20})`;
                    ctx.fillRect(-sz * 0.3, -sz * 0.5, sz * 0.6, sz * 0.5);
                    // Top ring
                    ctx.fillStyle = `rgb(${st + 20},${st + 5},${st - 10})`;
                    ctx.beginPath();
                    ctx.ellipse(0, -sz * 0.5, sz * 0.35, sz * 0.12, 0, 0, Math.PI * 2);
                    ctx.fill();
                    // Ring lines
                    ctx.strokeStyle = `rgba(${st - 5},${st - 15},${st - 30},0.4)`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.ellipse(0, -sz * 0.5, sz * 0.2, sz * 0.07, 0, 0, Math.PI * 2);
                    ctx.stroke();
                }

                ctx.restore();
            });

            // ===== LIGHT SHAFTS (golden beams) =====
            for (let i = 0; i < 4; i++) {
                const lx = ((i * 311 + totalTime * 15) % (W + 200)) - 100;
                const alpha = 0.03 + Math.sin(totalTime * 0.3 + i * 1.7) * 0.015;
                const w = 30 + Math.sin(i * 2.3) * 15;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.moveTo(lx, 0);
                ctx.lineTo(lx + w, 0);
                ctx.lineTo(lx + w * 3, H * 0.8);
                ctx.lineTo(lx + w * 2, H * 0.8);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        // ===== SCOUT TROOPER SPEEDER BIKE =====
        function drawScoutBike(e) {
            const depth = e.z;
            const scale = 1 / depth;
            const sx = (e.x - 0.5) * W * scale + W * 0.5;
            const sy = (e.y - 0.5) * H * scale + H * 0.5;
            const sz = Math.min(W, H) * 0.05 * scale;

            if (sz < 2 || sx < -150 || sx > W + 150 || sy < -150 || sy > H + 150) return;

            e.screenX = sx; e.screenY = sy; e.screenSize = sz;

            const flash = e.flash > 0;

            ctx.save();
            ctx.translate(sx, sy);

            // Speeder bike body — elongated horizontal shape
            const bikeGrad = ctx.createLinearGradient(-sz * 1.2, 0, sz * 1.2, 0);
            bikeGrad.addColorStop(0, flash ? '#aaaabc' : '#5a5a65');
            bikeGrad.addColorStop(0.5, flash ? '#888898' : '#6a6a75');
            bikeGrad.addColorStop(1, flash ? '#777788' : '#4a4a55');
            ctx.fillStyle = bikeGrad;
            ctx.beginPath();
            ctx.moveTo(-sz * 1.3, -sz * 0.1);
            ctx.lineTo(-sz * 0.8, -sz * 0.25);
            ctx.lineTo(sz * 0.6, -sz * 0.25);
            ctx.lineTo(sz * 1.4, -sz * 0.05);
            ctx.lineTo(sz * 1.4, sz * 0.1);
            ctx.lineTo(sz * 0.6, sz * 0.15);
            ctx.lineTo(-sz * 0.8, sz * 0.15);
            ctx.lineTo(-sz * 1.3, sz * 0.05);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = flash ? '#aaaabb' : '#3a3a45';
            ctx.lineWidth = Math.max(1, sz * 0.02);
            ctx.stroke();

            // Control vanes (two small fins on top)
            ctx.fillStyle = flash ? '#999aaa' : '#4a4a58';
            ctx.beginPath();
            ctx.moveTo(-sz * 0.3, -sz * 0.25);
            ctx.lineTo(-sz * 0.15, -sz * 0.5);
            ctx.lineTo(0, -sz * 0.25);
            ctx.closePath();
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(sz * 0.2, -sz * 0.25);
            ctx.lineTo(sz * 0.35, -sz * 0.45);
            ctx.lineTo(sz * 0.5, -sz * 0.25);
            ctx.closePath();
            ctx.fill();

            // Engine glow at rear
            const glowPulse = 0.6 + Math.sin(Date.now() * 0.01 + e.wobblePhase) * 0.3;
            ctx.fillStyle = `rgba(255,${Math.floor(100 + glowPulse * 60)},${Math.floor(20 + glowPulse * 20)},${0.6 + glowPulse * 0.3})`;
            ctx.shadowColor = '#ff6020';
            ctx.shadowBlur = 6 + glowPulse * 4;
            ctx.beginPath();
            ctx.ellipse(-sz * 1.3, 0, sz * 0.12, sz * 0.08, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Trooper body — hunched over handlebars
            // Torso
            ctx.fillStyle = flash ? '#eeeeee' : '#cccccc';
            ctx.beginPath();
            ctx.ellipse(sz * 0.1, -sz * 0.5, sz * 0.25, sz * 0.22, -0.2, 0, Math.PI * 2);
            ctx.fill();

            // Arms reaching to handlebars
            ctx.strokeStyle = flash ? '#dddddd' : '#111111';
            ctx.lineWidth = Math.max(1.5, sz * 0.06);
            ctx.beginPath();
            ctx.moveTo(sz * 0.25, -sz * 0.4);
            ctx.lineTo(sz * 0.6, -sz * 0.25);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(-sz * 0.05, -sz * 0.4);
            ctx.lineTo(sz * 0.3, -sz * 0.25);
            ctx.stroke();

            // Helmet
            const helmGrad = ctx.createRadialGradient(
                sz * 0.12, -sz * 0.78, 0,
                sz * 0.1, -sz * 0.72, sz * 0.2
            );
            helmGrad.addColorStop(0, flash ? '#ffffff' : '#e0e0e0');
            helmGrad.addColorStop(0.7, flash ? '#eeeeee' : '#c8c8c8');
            helmGrad.addColorStop(1, flash ? '#dddddd' : '#aaaaaa');
            ctx.fillStyle = helmGrad;
            ctx.beginPath();
            ctx.arc(sz * 0.1, -sz * 0.72, sz * 0.2, 0, Math.PI * 2);
            ctx.fill();

            // Visor (dark T-shape)
            ctx.fillStyle = flash ? '#444444' : '#1a1a1a';
            ctx.fillRect(sz * 0.02, -sz * 0.78, sz * 0.16, sz * 0.06);
            ctx.fillRect(sz * 0.08, -sz * 0.78, sz * 0.04, sz * 0.14);

            // Elite marker (red pauldron) for elites
            if (e.isElite) {
                ctx.fillStyle = '#cc2020';
                ctx.beginPath();
                ctx.ellipse(sz * 0.28, -sz * 0.55, sz * 0.08, sz * 0.05, 0.3, 0, Math.PI * 2);
                ctx.fill();
            }

            // Blaster flash effect when shooting
            if (flash) {
                ctx.fillStyle = 'rgba(255,60,60,0.5)';
                ctx.shadowColor = '#ff4040';
                ctx.shadowBlur = 12;
                ctx.beginPath();
                ctx.arc(sz * 1.5, 0, sz * 0.15, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            ctx.restore();
        }

        // ===== FLANKER (side-passing speeder bike) =====
        function drawFlankerBike(e) {
            // Same drawing, just re-use scout bike
            drawScoutBike(e);
        }

        function drawPlayerLaser(b) {
            const depth = b.z;
            if (depth < 0.15) return;
            const scale = 1 / depth;
            const sx = (b.x - 0.5) * W * scale + W * 0.5;
            const sy = (b.y - 0.5) * H * scale + H * 0.5;

            const trailDt = 0.015;
            const prevZ = b.z - b.vz * trailDt;
            if (prevZ < 0.1) return;
            const prevScale = 1 / prevZ;
            const prevX = ((b.x - b.vx * trailDt) - 0.5) * W * prevScale + W * 0.5;
            const prevY = ((b.y - b.vy * trailDt) - 0.5) * H * prevScale + H * 0.5;

            // Green rebel blaster bolt
            ctx.shadowColor = '#44ff44';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#44ff44';
            ctx.lineWidth = Math.max(2.5, 5 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();

            ctx.strokeStyle = '#88ff88';
            ctx.lineWidth = Math.max(1.5, 3 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();

            ctx.strokeStyle = '#ccffcc';
            ctx.lineWidth = Math.max(0.8, 1.5 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(sx, sy, Math.max(2, 3 * scale), 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEnemyLaser(b) {
            const depth = b.z;
            if (depth < 0.1) return;
            const scale = 1 / depth;
            const sx = (b.x - 0.5) * W * scale + W * 0.5;
            const sy = (b.y - 0.5) * H * scale + H * 0.5;

            const trailDt = 0.025;
            const prevZ = b.z - b.vz * trailDt;
            if (prevZ < 0.05 || prevZ > 8) return;
            const prevScale = 1 / prevZ;
            const prevX = ((b.x - b.vx * trailDt) - 0.5) * W * prevScale + W * 0.5;
            const prevY = ((b.y - b.vy * trailDt) - 0.5) * H * prevScale + H * 0.5;

            // Red Imperial blaster bolt
            ctx.shadowColor = '#ff2020';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#ff4040';
            ctx.lineWidth = Math.max(2.5, 5 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();

            ctx.strokeStyle = '#ff6060';
            ctx.lineWidth = Math.max(1.5, 3 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();

            ctx.strokeStyle = '#ffaaaa';
            ctx.lineWidth = Math.max(0.8, 1.5 * scale);
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.lineTo(prevX, prevY);
            ctx.stroke();
            ctx.shadowBlur = 0;

            ctx.fillStyle = '#ffcccc';
            ctx.beginPath();
            ctx.arc(sx, sy, Math.max(1.5, 2.5 * scale), 0, Math.PI * 2);
            ctx.fill();
        }

        function drawExplosion(ex) {
            const depth = ex.z;
            if (depth < 0.1) return;
            const scale = 1 / depth;
            const sx = (ex.x - 0.5) * W * scale + W * 0.5;
            const sy = (ex.y - 0.5) * H * scale + H * 0.5;
            const p = ex.progress;
            const r = (10 + p * 50) * scale;

            if (p < 0.5) {
                const fa = 1 - p * 2;
                const fireGrad = ctx.createRadialGradient(sx, sy, 0, sx, sy, r);
                fireGrad.addColorStop(0, `rgba(255,255,200,${fa})`);
                fireGrad.addColorStop(0.3, `rgba(255,150,30,${fa * 0.8})`);
                fireGrad.addColorStop(0.6, `rgba(255,60,10,${fa * 0.5})`);
                fireGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = fireGrad;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.strokeStyle = `rgba(255,100,20,${Math.max(0, 0.6 - p)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(sx, sy, r * 1.3, 0, Math.PI * 2);
            ctx.stroke();

            for (let i = 0; i < 8; i++) {
                const a = (i / 8) * Math.PI * 2 + ex.spin;
                const dist = r * (0.5 + p * 1.5);
                const alpha = Math.max(0, 1 - p * 1.3);
                ctx.fillStyle = i % 2 === 0
                    ? `rgba(255,200,50,${alpha})`
                    : `rgba(255,100,20,${alpha})`;
                ctx.beginPath();
                ctx.arc(sx + Math.cos(a) * dist, sy + Math.sin(a) * dist, 2 * scale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawDebris(d) {
            const depth = d.z;
            if (depth < 0.1) return;
            const scale = 1 / depth;
            const sx = (d.x - 0.5) * W * scale + W * 0.5;
            const sy = (d.y - 0.5) * H * scale + H * 0.5;
            const sz = d.size * scale;

            ctx.save();
            ctx.translate(sx, sy);
            ctx.rotate(d.rot);
            ctx.fillStyle = `rgba(100,100,110,${d.alpha})`;
            ctx.fillRect(-sz, -sz * 0.3, sz * 2, sz * 0.6);
            ctx.restore();
        }

        function drawCrosshair() {
            const cx = crossX * W, cy = crossY * H;
            const r = Math.min(W, H) * 0.025;

            // Green targeting brackets
            ctx.strokeStyle = 'rgba(68,255,68,0.6)';
            ctx.lineWidth = 2;
            const s = r * 1.3;

            ctx.beginPath();
            ctx.moveTo(cx - s, cy - s); ctx.lineTo(cx - s + r * 0.4, cy - s);
            ctx.moveTo(cx - s, cy - s); ctx.lineTo(cx - s, cy - s + r * 0.4);
            ctx.moveTo(cx + s, cy - s); ctx.lineTo(cx + s - r * 0.4, cy - s);
            ctx.moveTo(cx + s, cy - s); ctx.lineTo(cx + s, cy - s + r * 0.4);
            ctx.moveTo(cx - s, cy + s); ctx.lineTo(cx - s + r * 0.4, cy + s);
            ctx.moveTo(cx - s, cy + s); ctx.lineTo(cx - s, cy + s - r * 0.4);
            ctx.moveTo(cx + s, cy + s); ctx.lineTo(cx + s - r * 0.4, cy + s);
            ctx.moveTo(cx + s, cy + s); ctx.lineTo(cx + s, cy + s - r * 0.4);
            ctx.stroke();

            // Center dot
            ctx.fillStyle = 'rgba(68,255,68,0.7)';
            ctx.beginPath();
            ctx.arc(cx, cy, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        // ===== SPEEDER BIKE HUD =====
        function drawSpeederBike() {
            const s = Math.min(W, H);
            const tilt = swerveAmount * 0.08; // Handlebar tilt with swerve

            // Damage flash overlay
            if (dmgFlash > 0) {
                ctx.fillStyle = `rgba(255,100,50,${dmgFlash * 0.15})`;
                ctx.fillRect(0, 0, W, H);
            }

            ctx.save();
            ctx.translate(W * 0.5, H);
            ctx.rotate(tilt);
            ctx.translate(-W * 0.5, -H);

            // === NOSE CONE — central wedge from bottom center ===
            const noseTop = H * 0.82;
            const noseGrad = ctx.createLinearGradient(W * 0.5, noseTop, W * 0.5, H);
            noseGrad.addColorStop(0, '#4a4a55');
            noseGrad.addColorStop(0.3, '#3a3a45');
            noseGrad.addColorStop(1, '#2a2a32');
            ctx.fillStyle = noseGrad;
            ctx.beginPath();
            ctx.moveTo(W * 0.5, noseTop);
            ctx.lineTo(W * 0.42, H * 0.88);
            ctx.lineTo(W * 0.38, H);
            ctx.lineTo(W * 0.62, H);
            ctx.lineTo(W * 0.58, H * 0.88);
            ctx.closePath();
            ctx.fill();

            // Nose cone edge highlight
            ctx.strokeStyle = '#5a5a68';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(W * 0.5, noseTop);
            ctx.lineTo(W * 0.42, H * 0.88);
            ctx.lineTo(W * 0.38, H);
            ctx.moveTo(W * 0.5, noseTop);
            ctx.lineTo(W * 0.58, H * 0.88);
            ctx.lineTo(W * 0.62, H);
            ctx.stroke();

            // Center line on nose
            ctx.strokeStyle = '#333340';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(W * 0.5, noseTop);
            ctx.lineTo(W * 0.5, H);
            ctx.stroke();

            // === LEFT HANDLEBAR ===
            const lhX = W * 0.28;
            const lhY = H * 0.88;

            // Handle grip bar
            ctx.fillStyle = '#2a2a35';
            ctx.beginPath();
            ctx.moveTo(lhX - s * 0.04, lhY);
            ctx.lineTo(lhX + s * 0.01, lhY - H * 0.06);
            ctx.lineTo(lhX + s * 0.03, lhY - H * 0.06);
            ctx.lineTo(lhX + s * 0.01, lhY + H * 0.02);
            ctx.lineTo(lhX - s * 0.03, lhY + H * 0.02);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#444458';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Grip texture
            for (let i = 0; i < 4; i++) {
                const gy = lhY - H * 0.04 + i * H * 0.015;
                ctx.strokeStyle = 'rgba(80,80,100,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(lhX - s * 0.025, gy);
                ctx.lineTo(lhX + s * 0.015, gy);
                ctx.stroke();
            }

            // Speed readout (holographic blue text) on left bar
            const speedDisplay = lhX - s * 0.01;
            const speedY = lhY - H * 0.025;
            ctx.fillStyle = 'rgba(100,200,255,0.6)';
            ctx.font = `${s * 0.006}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            const speedVal = state === 'playing' ? (280 + Math.floor(Math.sin(totalTime * 2) * 15)) : 0;
            ctx.fillText(speedVal + ' KPH', speedDisplay, speedY);

            // === RIGHT HANDLEBAR ===
            const rhX = W * 0.72;
            const rhY = H * 0.88;

            ctx.fillStyle = '#2a2a35';
            ctx.beginPath();
            ctx.moveTo(rhX + s * 0.04, rhY);
            ctx.lineTo(rhX - s * 0.01, rhY - H * 0.06);
            ctx.lineTo(rhX - s * 0.03, rhY - H * 0.06);
            ctx.lineTo(rhX - s * 0.01, rhY + H * 0.02);
            ctx.lineTo(rhX + s * 0.03, rhY + H * 0.02);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#444458';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Grip texture
            for (let i = 0; i < 4; i++) {
                const gy = rhY - H * 0.04 + i * H * 0.015;
                ctx.strokeStyle = 'rgba(80,80,100,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(rhX - s * 0.015, gy);
                ctx.lineTo(rhX + s * 0.025, gy);
                ctx.stroke();
            }

            // Shield gauge on right bar
            const shX = rhX + s * 0.005;
            const shY = rhY - H * 0.04;
            const shW = s * 0.025;
            const shH = H * 0.035;

            // Shield bar background
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(shX - shW / 2, shY, shW, shH);
            ctx.strokeStyle = '#444458';
            ctx.lineWidth = 1;
            ctx.strokeRect(shX - shW / 2, shY, shW, shH);

            // Shield fill
            const shPct = shields / 100;
            const shColor = shPct > 0.5 ? '#44ff44' : (shPct > 0.25 ? '#ffaa20' : '#ff3030');
            ctx.fillStyle = shColor;
            ctx.globalAlpha = 0.7;
            ctx.fillRect(shX - shW / 2 + 1, shY + shH * (1 - shPct), shW - 2, shH * shPct);
            ctx.globalAlpha = 1;

            // Shield label
            ctx.fillStyle = 'rgba(100,200,255,0.5)';
            ctx.font = `${s * 0.005}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText('SH', shX, shY - 2);

            if (shields <= 25 && Math.floor(Date.now() / 300) % 2 === 0) {
                ctx.fillStyle = '#ff2020';
                ctx.font = `${s * 0.006}px 'Press Start 2P'`;
                ctx.fillText('LOW', shX, shY + shH / 2 + s * 0.003);
            }

            // === CONNECTING BAR between handlebars ===
            ctx.strokeStyle = '#3a3a48';
            ctx.lineWidth = Math.max(2, s * 0.003);
            ctx.beginPath();
            ctx.moveTo(lhX + s * 0.01, lhY + H * 0.01);
            ctx.quadraticCurveTo(W * 0.5, H * 0.92, rhX - s * 0.01, rhY + H * 0.01);
            ctx.stroke();

            // Muzzle flash from nose cone tip
            if (gunFlash > 0) {
                const gAlpha = gunFlash * 2;
                ctx.fillStyle = `rgba(68,255,68,${gAlpha * 0.5})`;
                ctx.shadowColor = '#44ff44';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                ctx.arc(W * 0.5, noseTop, s * 0.015, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            ctx.restore();

            // === HUD TEXT OVERLAY (green/forest theme) ===
            ctx.fillStyle = 'rgba(68,255,68,0.5)';
            ctx.font = `${s * 0.009}px 'Press Start 2P'`;
            ctx.textAlign = 'left';
            ctx.fillText('SCORE ' + String(score).padStart(6, '0'), W * 0.04, H * 0.05);
            ctx.textAlign = 'right';
            ctx.fillText('WAVE ' + wave + '/' + MAX_WAVES, W * 0.96, H * 0.05);
            ctx.textAlign = 'center';
            ctx.fillText('KILLS ' + killed + '/' + waveTarget, W * 0.5, H * 0.05);
        }

        // ===== COUNTDOWN / VICTORY =====
        function drawCountdown() {
            const cx = W / 2, cy = H * 0.4;
            ctx.shadowColor = 'rgba(68,255,68,0.4)'; ctx.shadowBlur = 10;
            ctx.fillStyle = '#44ff44';
            ctx.font = `${Math.min(W, H) * 0.018}px 'Press Start 2P'`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText('WAVE ' + wave, cx, cy - Math.min(W, H) * 0.08);

            const text = CD_TEXT[countdownPhase];
            if (text) {
                const isNum = ['3', '2', '1'].includes(text);
                const isGo = text === 'PUNCH IT!';
                const fontSize = isNum ? 0.08 : (isGo ? 0.05 : 0.016);
                const phase = countdownTimer / CD_DUR[countdownPhase];
                const scale = isNum ? 1 + Math.sin(phase * Math.PI) * 0.15 : 1;
                const alpha = isGo ? Math.max(0, 1 - phase * 2) : 1;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(scale, scale);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = isGo ? '#ffaa00' : (text === 'ALL SPEEDERS LAUNCH' ? '#44ff44' : '#88ff44');
                ctx.font = `${Math.min(W, H) * fontSize}px 'Press Start 2P'`;
                ctx.fillText(text, 0, 0);
                ctx.restore();
                ctx.globalAlpha = 1;
            }
            ctx.shadowBlur = 0;
        }

        function drawVictory(dt) {
            victoryTimer += dt;
            const cx = W / 2, cy = H * 0.35;
            const t = victoryTimer;
            const s = Math.min(W, H);

            if (t > 1.5) {
                const ta = Math.min(1, (t - 1.5) / 1);
                ctx.globalAlpha = ta;
                ctx.shadowColor = 'rgba(68,255,68,0.5)'; ctx.shadowBlur = 15;

                const pulse = 1 + Math.sin(t * 4) * 0.04;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.scale(pulse, pulse);
                ctx.fillStyle = '#44ff44';
                ctx.font = `${s * 0.035}px 'Press Start 2P'`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('FOREST CLEARED', 0, 0);
                ctx.restore();

                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffaa00';
                ctx.font = `${s * 0.016}px 'Press Start 2P'`;
                ctx.textAlign = 'center';
                ctx.fillText('SHIELD GENERATOR EXPOSED', cx, cy + s * 0.07);

                ctx.fillStyle = '#44ff44';
                ctx.font = `${s * 0.014}px 'Press Start 2P'`;
                ctx.fillText('SCORE: ' + String(score).padStart(6, '0'), cx, cy + s * 0.13);

                ctx.fillStyle = '#ffaa00';
                ctx.font = `${s * 0.012}px 'Press Start 2P'`;
                ctx.fillText('THE FORCE IS WITH YOU', cx, cy + s * 0.18);

                if (t > 3.5 && Math.floor(t * 2) % 2 === 0) {
                    ctx.fillStyle = '#44ff44';
                    ctx.font = `${s * 0.01}px 'Press Start 2P'`;
                    ctx.fillText('CLICK OR PRESS ENTER TO PLAY AGAIN', cx, cy + s * 0.25);
                }
                ctx.globalAlpha = 1;
            }
        }

        // ===== LOGIC =====
        function getWaveConfig(w) {
            return {
                target: 5 + w * 2,
                spawnInt: Math.max(1000 - w * 80, 400),
                maxOn: Math.min(4 + w, 12),
                eliteChance: w >= 3 ? Math.min(0.15 + (w - 3) * 0.06, 0.4) : 0,
                flankerChance: Math.min(0.1 + w * 0.03, 0.25),
            };
        }

        function spawnEnemy() {
            const cfg = getWaveConfig(wave);
            const roll = Math.random();
            const isElite = roll < cfg.eliteChance;
            const isFlanker = !isElite && roll < cfg.eliteChance + cfg.flankerChance;

            let x, y, z, vx, vy, vz;
            let flyby = false;

            if (isFlanker) {
                // Flankers come from sides
                flyby = true;
                if (Math.random() < 0.5) {
                    x = -0.5; y = 0.3 + Math.random() * 0.3;
                    z = 1.2 + Math.random() * 1.0;
                    vx = 0.45 + Math.random() * 0.3;
                } else {
                    x = 1.5; y = 0.3 + Math.random() * 0.3;
                    z = 1.2 + Math.random() * 1.0;
                    vx = -(0.45 + Math.random() * 0.3);
                }
                vy = (Math.random() - 0.5) * 0.1;
                vz = -(0.05 + Math.random() * 0.1);
            } else {
                // Standard approach — appear ahead in forest
                const spawnType = Math.random();

                if (spawnType < 0.25) {
                    // From left ahead
                    x = -0.2 + Math.random() * 0.2;
                    y = 0.25 + Math.random() * 0.35;
                    z = 3 + Math.random() * 2;
                    vx = 0.1 + Math.random() * 0.15;
                    vy = (Math.random() - 0.5) * 0.1;
                } else if (spawnType < 0.5) {
                    // From right ahead
                    x = 0.8 + Math.random() * 0.2;
                    y = 0.25 + Math.random() * 0.35;
                    z = 3 + Math.random() * 2;
                    vx = -(0.1 + Math.random() * 0.15);
                    vy = (Math.random() - 0.5) * 0.1;
                } else if (spawnType < 0.75) {
                    // Dead ahead
                    x = 0.3 + Math.random() * 0.4;
                    y = 0.2 + Math.random() * 0.35;
                    z = 4 + Math.random() * 3;
                    vx = (Math.random() - 0.5) * 0.15;
                    vy = (Math.random() - 0.5) * 0.08;
                } else {
                    // From above/below
                    x = 0.2 + Math.random() * 0.6;
                    y = Math.random() < 0.5 ? -0.1 : 1.0;
                    z = 2.5 + Math.random() * 2;
                    vx = (Math.random() - 0.5) * 0.12;
                    vy = y < 0 ? (0.1 + Math.random() * 0.1) : -(0.1 + Math.random() * 0.1);
                }

                vz = -(0.3 + Math.random() * 0.25 + wave * 0.04);
            }

            enemies.push({
                x, y, z, vx, vy, vz,
                alive: true, t: 0, flyby,
                isElite,
                isFlanker,
                life: flyby ? 6000 + Math.random() * 3000 : 10000 + Math.random() * 5000,
                shootCD: flyby ? 800 + Math.random() * 800 : (isElite ? 1200 + Math.random() * 800 : 2500 + Math.random() * 2000),
                flash: 0,
                hp: isElite ? 2 : 1,
                screenX: 0, screenY: 0, screenSize: 0,
                wobblePhase: Math.random() * Math.PI * 2,
                wobbleSpd: flyby ? 0.5 : (1.0 + Math.random() * 2.0),
            });
        }

        function shoot() {
            if (state !== 'playing') return;
            sfx.play('laser');
            gunFlash = 0.2;

            // Fire from nose cone tip
            const startZ = 0.3;
            const targetZ = 3.5;

            const targetX = (crossX - 0.5) * targetZ + 0.5;
            const targetY = (crossY - 0.5) * targetZ + 0.5;

            // Single gun from nose cone
            const gunWorldX = 0.5 + camX;
            const gunWorldY = 0.82 + camY;
            const gx = (gunWorldX - 0.5) * startZ + 0.5;
            const gy = (gunWorldY - 0.5) * startZ + 0.5;

            const dx = targetX - gx;
            const dy = targetY - gy;
            const dz = targetZ - startZ;
            const d = Math.sqrt(dx * dx + dy * dy + dz * dz);
            const speed = 5.0;

            // Twin bolts (slight offset)
            [-0.015, 0.015].forEach(offset => {
                playerLasers.push({
                    x: gx + offset, y: gy, z: startZ,
                    vx: (dx / d) * speed,
                    vy: (dy / d) * speed,
                    vz: (dz / d) * speed,
                });
            });
        }

        function takeDamage(amount) {
            shields -= amount;
            sfx.play('hit');
            shakeTimer = 0.3;
            dmgFlash = 1;
            if (shields <= 25) sfx.play('shield_alarm');
            if (shields <= 0) {
                shields = 0;
                state = 'gameover'; sfx.play('gameover');
                document.getElementById('finalScore').textContent = 'SCORE: ' + String(score).padStart(6, '0');
                document.getElementById('gameOverOverlay').style.display = 'flex';
            }
        }

        function startCountdown() {
            state = 'countdown'; countdownPhase = 0; countdownTimer = 0;
            enemies = []; explosions = []; playerLasers = []; enemyLasers = [];
            debris = [];
            const cfg = getWaveConfig(wave);
            waveTarget = cfg.target; spawnInterval = cfg.spawnInt; maxOnScreen = cfg.maxOn;
            killed = 0; spawnTimer = 0;
        }

        function nextWave() {
            if (wave >= MAX_WAVES) {
                state = 'victory'; victoryTimer = 0; sfx.play('victory');
                document.getElementById('winOverlay').style.display = 'flex';
                return;
            }
            wave++; startCountdown();
        }

        function updateCountdown(dt) {
            countdownTimer += dt * 1000;
            if (countdownTimer >= CD_DUR[countdownPhase]) {
                countdownTimer = 0; countdownPhase++;
                if (countdownPhase >= 2 && countdownPhase <= 4) sfx.play('countdown');
                if (countdownPhase === 5) sfx.play('go');
                if (countdownPhase >= CD_DUR.length) { state = 'playing'; return; }
            }
        }

        function updateSwerve(dt) {
            swerveTimer += dt;
            if (swerveTimer >= swerveInterval) {
                swerveTimer = 0;
                swerveInterval = 1.5 + Math.random() * 1.5;
                const dir = Math.random() < 0.5 ? -1 : 1;
                const intensity = 0.3 + Math.random() * 0.7;
                swerveTarget = dir * intensity;
            }
            // Smooth interpolation toward target
            swerveAmount += (swerveTarget - swerveAmount) * Math.min(1, dt * 2.5);
        }

        function update(dt) {
            dmgFlash = Math.max(0, dmgFlash - dt * 3);
            gunFlash = Math.max(0, gunFlash - dt * 3);
            if (shakeTimer > 0) {
                shakeTimer -= dt;
                shakeX = (Math.random() - 0.5) * 8;
                shakeY = (Math.random() - 0.5) * 8;
            } else { shakeX = 0; shakeY = 0; }

            // Always update swerve (even during countdown for visual continuity)
            if (state === 'playing' || state === 'countdown') {
                updateSwerve(dt);
            }

            if (state === 'countdown') { updateCountdown(dt); return; }
            if (state !== 'playing') return;

            // Crosshair movement
            const cs = 0.8;
            if (keys['ArrowLeft'] || keys['a']) crossX -= cs * dt;
            if (keys['ArrowRight'] || keys['d']) crossX += cs * dt;
            if (keys['ArrowUp'] || keys['w']) crossY -= cs * dt;
            if (keys['ArrowDown'] || keys['s']) crossY += cs * dt;
            crossX = Math.max(0.05, Math.min(0.95, crossX));
            crossY = Math.max(0.05, Math.min(0.95, crossY));

            // Camera pans (subtle — open air, no cockpit blocking view)
            const targetCamX = (crossX - 0.5) * 0.12;
            const targetCamY = (crossY - 0.5) * 0.08;
            const camSmooth = Math.min(1, dt * 5);
            camX += (targetCamX - camX) * camSmooth;
            camY += (targetCamY - camY) * camSmooth;

            // Spawn
            spawnTimer += dt * 1000;
            if (spawnTimer >= spawnInterval && enemies.filter(e => e.alive).length < maxOnScreen) {
                spawnEnemy(); spawnTimer = 0;
            }

            // Update enemies
            enemies.forEach(e => {
                if (!e.alive) return;
                e.t += dt * 1000;

                const wobAmt = e.flyby ? 0.02 : 0.06;
                e.x += e.vx * dt + Math.sin(e.t * 0.002 * e.wobbleSpd + e.wobblePhase) * wobAmt * dt;
                e.y += e.vy * dt + Math.cos(e.t * 0.0025 * e.wobbleSpd) * wobAmt * 0.75 * dt;
                e.z += e.vz * dt;

                if (e.flyby) {
                    if (e.x < -0.8 || e.x > 1.8 || e.y < -0.5 || e.y > 1.5) { e.alive = false; return; }
                } else {
                    e.x = Math.max(-0.5, Math.min(1.5, e.x));
                    e.y = Math.max(-0.3, Math.min(1.0, e.y));
                }

                if (e.z < 0.3) { e.alive = false; return; }

                // Shoot at player
                e.shootCD -= dt * 1000;
                if (e.shootCD <= 0 && e.z < 3.0) {
                    e.flash = 150;
                    e.shootCD = e.isElite
                        ? Math.max(800, 1800 - wave * 80) + Math.random() * 800
                        : Math.max(1500, 3000 - wave * 120) + Math.random() * 1500;
                    sfx.play('enemy_laser');

                    const dx = 0.5 - e.x + (Math.random() - 0.5) * 0.15;
                    const dy = 0.7 - e.y;
                    const dz = -e.z;
                    const d = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    const bspd = 2.5 + wave * 0.1;
                    enemyLasers.push({
                        x: e.x, y: e.y, z: e.z,
                        vx: (dx / d) * bspd, vy: (dy / d) * bspd, vz: (dz / d) * bspd,
                    });
                }
                if (e.flash > 0) e.flash -= dt * 1000;
                if (e.t > e.life) e.alive = false;
            });
            enemies = enemies.filter(e => e.alive);

            // Player lasers
            playerLasers = playerLasers.filter(b => {
                b.x += b.vx * dt; b.y += b.vy * dt; b.z += b.vz * dt;
                for (let e of enemies) {
                    if (!e.alive) continue;
                    const dx = b.x - e.x, dy = b.y - e.y, dz = b.z - e.z;
                    const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    const hitRadius = 0.2;
                    if (dist < hitRadius) {
                        if (e.hp > 1) {
                            e.hp--; e.flash = 200;
                            sfx.play('hit');
                        } else {
                            e.alive = false;
                            if (e.isFlanker) {
                                score += 800 * wave;
                            } else if (e.isElite) {
                                score += 750 * wave;
                            } else {
                                score += 500 * wave;
                            }
                            killed++;
                            sfx.play('explode');
                            explosions.push({ x: e.x, y: e.y, z: e.z, progress: 0, spin: Math.random() * Math.PI * 2 });
                            for (let i = 0; i < 6; i++) {
                                debris.push({
                                    x: e.x, y: e.y, z: e.z,
                                    vx: (Math.random() - 0.5) * 0.8,
                                    vy: (Math.random() - 0.5) * 0.8,
                                    vz: (Math.random() - 0.5) * 0.5,
                                    rot: Math.random() * Math.PI * 2,
                                    rotV: (Math.random() - 0.5) * 5,
                                    size: 3 + Math.random() * 5,
                                    alpha: 1, life: 1.5 + Math.random(),
                                });
                            }
                        }
                        return false;
                    }
                }
                return b.z > 0 && b.z < 6;
            });

            // Enemy lasers
            enemyLasers = enemyLasers.filter(b => {
                b.x += b.vx * dt; b.y += b.vy * dt; b.z += b.vz * dt;
                if (b.z < 0.2 && Math.abs(b.x - 0.5) < 0.2 && Math.abs(b.y - 0.5) < 0.3) {
                    const dmg = 5 + wave;
                    takeDamage(dmg);
                    return false;
                }
                return b.z > -0.5 && b.z < 5;
            });

            explosions.forEach(ex => { ex.progress += dt * 2.0; ex.spin += dt * 3; });
            explosions = explosions.filter(ex => ex.progress < 1);

            debris.forEach(d => {
                d.x += d.vx * dt; d.y += d.vy * dt; d.z += d.vz * dt;
                d.rot += d.rotV * dt;
                d.alpha -= dt * 0.5; d.life -= dt;
            });
            debris = debris.filter(d => d.life > 0 && d.alpha > 0);

            if (killed >= waveTarget) nextWave();
        }

        function draw(dt) {
            ctx.clearRect(0, 0, W, H);

            // Camera pan offset (small)
            const camPxX = -camX * W;
            const camPxY = -camY * H;

            // Forest draws full-screen (no translate — it handles its own projection)
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawEndorForest(dt);
            ctx.restore();

            if (state === 'victory') {
                drawSpeederBike();
                ctx.save();
                ctx.translate(shakeX + camPxX, shakeY + camPxY);
                drawVictory(dt);
                ctx.restore();
                return;
            }

            // Sort everything by depth (painter's algorithm)
            const allObjects = [];

            enemies.forEach(e => { if (e.alive) allObjects.push({ type: 'enemy', obj: e, z: e.z }); });
            playerLasers.forEach(b => allObjects.push({ type: 'plaser', obj: b, z: b.z }));
            enemyLasers.forEach(b => allObjects.push({ type: 'elaser', obj: b, z: b.z }));
            explosions.forEach(ex => allObjects.push({ type: 'explosion', obj: ex, z: ex.z }));
            debris.forEach(d => allObjects.push({ type: 'debris', obj: d, z: d.z }));

            allObjects.sort((a, b) => b.z - a.z);

            ctx.save();
            ctx.translate(shakeX + camPxX, shakeY + camPxY);
            allObjects.forEach(o => {
                if (o.type === 'enemy') drawScoutBike(o.obj);
                else if (o.type === 'plaser') drawPlayerLaser(o.obj);
                else if (o.type === 'elaser') drawEnemyLaser(o.obj);
                else if (o.type === 'explosion') drawExplosion(o.obj);
                else if (o.type === 'debris') drawDebris(o.obj);
            });
            ctx.restore();

            // Speeder bike HUD always on top
            ctx.save();
            ctx.translate(shakeX, shakeY);
            drawSpeederBike();

            if (state === 'countdown') {
                drawCountdown();
            }
            ctx.restore();

            if (state === 'playing') {
                ctx.save();
                ctx.translate(shakeX + camPxX, shakeY + camPxY);
                drawCrosshair();
                ctx.restore();
            }
        }

        function loop(ts) {
            const dt = Math.min((ts - lastTime) / 1000, 0.05);
            lastTime = ts;
            resize(); update(dt); draw(dt);
            requestAnimationFrame(loop);
        }

        function startGame() {
            score = 0; shields = 100; wave = 1;
            enemies = []; explosions = []; playerLasers = []; enemyLasers = [];
            debris = [];
            crossX = 0.5; crossY = 0.4; camX = 0; camY = 0; shakeTimer = 0; dmgFlash = 0; gunFlash = 0;
            swerveAmount = 0; swerveTarget = 0; swerveTimer = 0; totalTime = 0;
            initForest();
            document.getElementById('startOverlay').style.display = 'none';
            document.getElementById('gameOverOverlay').style.display = 'none';
            document.getElementById('winOverlay').style.display = 'none';
            sfx.init(); startCountdown();
        }

        // ===== INPUT =====
        document.addEventListener('keydown', e => {
            keys[e.key] = true;
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                if (state === 'start' || state === 'gameover' || state === 'victory') startGame();
                else if (state === 'playing' && e.key === ' ') shoot();
            }
        });
        document.addEventListener('keyup', e => { keys[e.key] = false; });

        function screenToGame(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: Math.max(0.05, Math.min(0.95, (clientX - rect.left) / rect.width)),
                y: Math.max(0.05, Math.min(0.95, (clientY - rect.top) / rect.height)),
            };
        }

        canvas.addEventListener('mousemove', e => {
            if (state !== 'playing') return;
            const pos = screenToGame(e.clientX, e.clientY);
            crossX = pos.x; crossY = pos.y;
        });

        canvas.addEventListener('click', e => {
            e.preventDefault(); sfx.init();
            if (state === 'start' || state === 'gameover' || state === 'victory') startGame();
            else if (state === 'playing') {
                const pos = screenToGame(e.clientX, e.clientY);
                crossX = pos.x; crossY = pos.y;
                shoot();
            }
        });

        canvas.addEventListener('touchstart', e => {
            e.preventDefault(); sfx.init();
            if (state === 'start' || state === 'gameover' || state === 'victory') { startGame(); return; }
            if (state === 'playing') {
                const pos = screenToGame(e.touches[0].clientX, e.touches[0].clientY);
                crossX = pos.x; crossY = pos.y;
                shoot();
            }
        }, { passive: false });

        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            if (state !== 'playing') return;
            const pos = screenToGame(e.touches[0].clientX, e.touches[0].clientY);
            crossX = pos.x; crossY = pos.y;
        }, { passive: false });

        ['startOverlay', 'gameOverOverlay', 'winOverlay'].forEach(id => {
            const el = document.getElementById(id);
            el.addEventListener('click', e => { e.preventDefault(); e.stopPropagation(); sfx.init(); startGame(); });
            el.addEventListener('touchstart', e => { e.preventDefault(); e.stopPropagation(); sfx.init(); startGame(); }, { passive: false });
        });

        requestAnimationFrame(loop);
    </script>
</body>

</html>
